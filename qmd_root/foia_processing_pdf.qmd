---
title: "Supplementary Material: FOIA Document OCR Processing"
subtitle: "Processing Murphy & Tong FOIA Documents about State DNA Database Racial Composition"
format:
  pdf:
    toc: false
    number-sections: true
    keep-tex: false
    documentclass: article
    geometry:
      - top=1in
      - bottom=1in
      - left=0.8in
      - right=0.8in
    fontsize: 11pt
    fig-width: 8
    fig-height: 6
    df-print: kable
    include-in-header:
      text: |
        \newcommand{\forcebreak}{\newpage}
         \usepackage{caption}
         \captionsetup[figure]{font=large}
editor: 
  markdown: 
    wrap: 72
execute:
  echo: true
  warning: false
  message: false
  results: hold
---

# Overview

This document details the processing of Freedom of Information Act (FOIA) responses from seven U.S. states regarding the demographic composition of their State DNA Index System (SDIS) databases. These responses were obtained by Professor Erin Murphy (NYU Law) in 2018 as part of research on racial disparities in DNA databases.

# Materials and Methods

## Data Sources

### Raw FOIA Responses

The original FOIA responses are stored in two formats:

-   **PDFs**: `raw/foia_pdfs/` - Original scanned documents
-   **HTML**: `raw/foia_html/` - OCR'd versions for easier extraction

```{r}
#| label: setup
#| echo: false

# List of required packages
required_packages <- c(
  "tidyverse",    # Data manipulation and visualization
  "here",         # File path management
  "knitr",        # Dynamic report generation
  "kableExtra",   # Enhanced table formatting
  "ggplot2",      # Data visualization
  "patchwork",    # Plot composition and layout
  "scales",       # Axis scaling and formatting
  "tidyr",        # Data tidying and reshaping
  "tibble",       # Modern data frames
  "flextable",    # Advanced table formatting
  "DT",           # Interactive tables
  "cowplot",      # Plotting composition
  "sf",           # Simple Features for spatial data
  "usmap"        # Mapping US states
)
  
# Function to install missing packages
install_missing <- function(packages) {
  for (pkg in packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      message(paste("Installing missing package:", pkg))
      install.packages(pkg, dependencies = TRUE)
    }
  }
}

# Install any missing packages
install_missing(required_packages)

# Load all packages
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
  library(knitr)
  library(kableExtra)
  library(ggplot2)
  library(patchwork)
  library(scales)
  library(tidyr)
  library(tibble)
  library(flextable)
  library(cowplot)
  library(sf)
  library(usmap)
})

# Verify all packages loaded successfully
loaded_packages <- sapply(required_packages, require, character.only = TRUE)
if (all(loaded_packages)) {
  message("All packages loaded successfully!")
} else {
  warning("The following packages failed to load: ", 
          paste(names(loaded_packages)[!loaded_packages], collapse = ", "))
}

# Display options
options(tibble.width = Inf)
options(dplyr.summarise.inform = FALSE)

# Path to per-state files (run notebook from analysis/)
base_dir <- here("..")
per_state <- here("data", "foia", "intermediate")

# Discover available per-state CSV files
state_files <- list.files(per_state, pattern = "*_foia_data\\.csv$", full.names = TRUE)

if (length(state_files) == 0) {
  stop(paste("No per-state FOIA files found in", per_state, ". Check the folder path."))
}

stem_to_state <- function(stem) {
  toks <- str_split(stem, "_")[[1]]
  if ("foia" %in% toks) {
    toks <- toks[1:(which(toks == "foia") - 1)]
  }
  paste(tools::toTitleCase(toks), collapse = " ")
}

states_available <- map_chr(basename(state_files), ~ stem_to_state(str_remove(.x, "_foia_data\\.csv")))

cat(paste("✓ ", length(state_files), "per-state files:\n"))
for (s in states_available) {
  cat(paste("  •", s, "\n"))
}

# Initialize empty containers for the loop that follows
foia_combined <- tibble()
foia_state_metadata <- list()
```

## Processing workflow

For transparency, each state file is processed independently then merged
into a single **combined long‑format table (`foia_combined`)**:

1.  **Load one file per state** from `data/foia/intermediate/`.

2.  **Append** its rows to `foia_combined`. A parallel dataframe,
    **`foia_state_metadata`**, records what each state reported (counts,
    percentages, which categories) and any state-specific
    characteristics (e.g. Nevada's "flags" terminology).

3.  **Quality‑check each state**:

    -   verify that race and gender percentages sum to ≈ 100 % when
        provided,
    -   confirm that demographic counts sum to the state's reported
        total profiles,
    -   **calculate** any missing counts or percentages and tag those
        rows `value_source = "calculated"`.

4.  **Save outputs**

    -   `data/foia/final/foia_data_clean.csv` — the fully combined tidy
        table with both reported and calculated values,
    -   `data/foia/intermediate/foia_state_metadata.csv` — one row per state
        summarising coverage and caveats. After QC passes, freeze
        `foia_data_clean.csv` to `data/v1.0/FOIA_demographics.csv`.

## Helper Functions

The functions below perform each transformation required for harmonizing
the state‑level FOIA tables.

### Data Processing Helper Functions Reference

| Function | Definition | Parameters |
|:-----------------------|:-----------------------|:-----------------------|
| `load_state()` | Loads and preprocesses state FOIA data files, handling numeric conversion and validation | `path`: File path to state CSV |
| `enhanced_glimpse()` | Provides an enhanced data overview with column types, missing values, unique counts, and unique values | `df`: Input dataframe |
| `fill_demographic_gaps()` | Fills missing gender counts and adds Unknown race category when totals permit calculation | `df`: Input dataframe |
| `add_combined()` | Creates Combined offender type by summing Convicted Offender and Arrestee counts when missing | `df`: Input dataframe |
| `add_percentages()` | Derives percentage values from counts for all demographic categories | `df`: Input dataframe |
| `counts_consistent()` | Verifies that demographic counts sum to total_profiles for each offender type | `df`: Input dataframe |
| `percentages_consistent()` | Verifies that percentages sum to 100 ± 0.5% for each category | `df`: Input dataframe |
| `report_status()` | Reports what data types (counts/percentages/both) are available for a category | `df`: Input dataframe, `category`: race or gender |
| `verify_category_totals()` | Compares demographic sums against reported totals and shows differences | `df`: Input dataframe |
| `verify_percentage_consistency()` | Compares reported vs calculated percentages for consistency | `df_combined`: Combined dataframe, `state_name`: State name |
| `calculate_combined_totals()` | Calculates Combined totals by summing across offender types | `df`: Input dataframe, `state_name`: State name |
| `calculate_percentages()` | Calculates percentages from counts for demographic categories | `df_combined`: Combined dataframe, `state_name`: State name |
| `calculate_counts_from_percentages()` | Calculates counts from percentages for demographic categories | `df_combined`: Combined dataframe, `state_name`: State name |
| `standardize_offender_types()` | Standardizes offender type names to consistent terminology | `df`: Input dataframe |
| `prepare_state_for_combined()` | Prepares state data for inclusion in combined dataset with proper columns | `df`: Input dataframe, `state_name`: State name |
| `format_compact()` | Formats large numbers with K/M suffixes for readability | `x`: Numeric value |
| `create_pie_chart()` | Creates pie charts for specific demographic categories | `data`: Input data, `offender_type`, `category`, `value_type`, `title`, `show_values` |
| `create_state_visualizations()` | Creates comprehensive pie chart visualizations for all metrics | `df_combined`: Combined dataframe, `state_name`: State name |
| `create_demographic_bar_charts()` | Creates side-by-side bar charts for gender and race distributions | `df_combined`: Combined dataframe, `state_name`: State name |
| `add_state_metadata()` | Creates and appends a metadata record capturing state data characteristics including available offender types, demographic categories, data formats, and special features | `df`: Input dataframe, `state_name`: State name |
| `update_state_metadata()` | Modifies existing state metadata to update QC results (count/percentage consistency) and append validation notes | `state_name`: State name, `counts_ok`: Count consistency flag, `percentages_ok`: Percentage consistency flag, `notes_text`: Additional notes |

```{r}
#| label: helper-functions-setup
#| echo: true
#| warning: false
#| results: hold
#| message: false

## Helper functions setup --

# Columns retained from every raw table
COLS_NEEDED <- c("state", "offender_type", "variable_category",
                 "variable_detailed", "value", "value_type")

# ------------------------------------------------------------------
# 1. Load and preprocess state files
# ------------------------------------------------------------------
load_state <- function(path) {
  "
  Read a *_foia_data.csv* file, enforce column order,
  and convert <1 to 0.5 so that trace counts are retained.
  Execution halts if non-numeric values remain.
  "
  df <- read_csv(path, show_col_types = FALSE)
  if (!"state" %in% colnames(df)) {
    df <- df %>%
      mutate(state = str_remove(basename(path), "_foia_data\\.csv") %>%
        str_replace_all("_", " ") %>%
        tools::toTitleCase())
  }
  df <- df %>% select(all_of(COLS_NEEDED))
  df$value_source <- "reported"

  df <- df %>%
    mutate(value = ifelse(value == "<1", 0.5, value),
           value = as.numeric(value))
  
  nonnumeric <- df %>% filter(is.na(value))
  if (nrow(nonnumeric) > 0) {
    cat(paste("**Non-numeric rows in", basename(path), "; please amend**\n"))
    print(nonnumeric)
    stop("Numeric coercion failure")
  }
  return(df)
}


# ------------------------------------------------------------------
# 2. Enhanced glimpse
# ------------------------------------------------------------------
# Display data types for each column with unique values
enhanced_glimpse <- function(df) {
  glimpse_data <- data.frame(
    Column = names(df),
    Type = sapply(df, function(x) paste(class(x), collapse = ", ")),
    Rows = nrow(df),
    Missing = sapply(df, function(x) sum(is.na(x))),
    Unique = sapply(df, function(x) length(unique(x))),
    Unique_Values = sapply(df, function(x) {
      unique_vals <- unique(x)
      if (length(unique_vals) > 10) {
        paste(encodeString(as.character(unique_vals[1:10])), collapse = ", ", "...")
      } else {
        paste(encodeString(as.character(unique_vals)), collapse = ", ")
      }
    })
  )
  
  ft <- flextable(glimpse_data) %>%
    theme_zebra() %>%
    set_caption(paste("Enhanced Data Glimpse:", deparse(substitute(df)))) %>%
    autofit() %>%
    align(align = "left", part = "all") %>%
    colformat_num(j = c("Rows", "Missing", "Unique"), big.mark = "") %>%
    bg(j = "Missing", bg = function(x) ifelse(x > 0, "#FFF3CD", "transparent")) %>%
    bg(j = "Unique", bg = function(x) ifelse(x == 1, "#FFF3CD", "transparent")) %>%
    add_footer_lines(paste("Data frame dimensions:", nrow(df), "rows ×", ncol(df), "columns")) %>%
    fontsize(size = 10, part = "all") %>%
    set_table_properties(layout = "autofit", width = 1)
  
  return(ft)
}

# ------------------------------------------------------------------
# 3. Fill missing Male counts and Unknown race counts
# ------------------------------------------------------------------
fill_demographic_gaps <- function(df) {
  "If exactly one gender or the Unknown race category is absent and
  totals permit a residual, calculate and insert the missing count.
  "
  inserts <- list()
  
  for (ot in unique(df$offender_type)) {
    tot <- df %>%
      filter(offender_type == ot,
             variable_category == "total",
             variable_detailed == "total_profiles",
             value_type == "count")
    
    if (nrow(tot) == 0) next
    
    total <- tot$value[1]
    
    # gender residual ----------------------------------------------
    g <- df %>%
      filter(offender_type == ot,
             variable_category == "gender",
             value_type == "count")
    
    missing_gender <- setdiff(c("Male", "Female"), unique(g$variable_detailed))
    if (nrow(g) == 1 && length(missing_gender) == 1) {
      inserts[[length(inserts) + 1]] <- tibble(
        state = df$state[1],
        offender_type = ot,
        variable_category = "gender",
        variable_detailed = missing_gender,
        value = total - sum(g$value),
        value_type = "count",
        value_source = "calculated"
      )
    }
    
    # race residual -----------------------------------------------
    r <- df %>%
      filter(offender_type == ot,
             variable_category == "race",
             value_type == "count")
    
    if (nrow(r) > 0 && !"Unknown" %in% r$variable_detailed) {
      gap <- total - sum(r$value)
      if (gap > 0) {
        inserts[[length(inserts) + 1]] <- tibble(
          state = df$state[1],
          offender_type = ot,
          variable_category = "race",
          variable_detailed = "Unknown",
          value = gap,
          value_type = "count",
          value_source = "calculated"
        )
      }
    }
  }
  
  if (length(inserts) > 0) {
    df <- bind_rows(df, bind_rows(inserts))
  }
  return(df)
}

# ------------------------------------------------------------------
# 4. Construct Combined offender type if absent (add_combined)
# ------------------------------------------------------------------
add_combined <- function(df) {
  "
  When a state reports Convicted Offender and Arrestee counts but
  omits Combined, create a Combined block by summing the two.
  "
  if ("Combined" %in% df$offender_type) return(df)
  
  required <- c("Convicted Offender", "Arrestee")
  if (!all(required %in% df$offender_type)) return(df)  # cannot construct
  
  summed <- df %>%
    filter(value_type == "count") %>%
    group_by(variable_category, variable_detailed, value_type) %>%
    summarise(value = sum(value), .groups = "drop") %>%
    mutate(state = df$state[1],
           offender_type = "Combined",
           value_source = "calculated")
  
  return(bind_rows(df, summed))
}

# ------------------------------------------------------------------
# 5. Derive percentages wherever only counts exist (add_percentages)
# ------------------------------------------------------------------
add_percentages <- function(df) {
  "
  Ensure that every gender and race row has both count and percentage
  values, derived from the offender-type total if necessary.
  "
  totals <- df %>%
    filter(variable_category == "total",
           variable_detailed == "total_profiles",
           value_type == "count") %>%
    select(offender_type, value) %>%
    deframe()
  
  need_pct <- df %>%
    filter(value_type == "count",
           variable_category != "total")
  
  new_pct_rows <- need_pct %>%
    rowwise() %>%
    mutate(has_percentage = nrow(df %>%
           filter(state == state,
                  offender_type == offender_type,
                  variable_category == variable_category,
                  variable_detailed == variable_detailed,
                  value_type == "percentage"))) %>%
    filter(has_percentage == 0) %>%
    mutate(value = round(value / totals[offender_type] * 100, 2),
           value_type = "percentage",
           value_source = "calculated") %>%
    select(-has_percentage)
  
  if (nrow(new_pct_rows) > 0) {
    df <- bind_rows(df, new_pct_rows)
  }
  return(df)
}

# ------------------------------------------------------------------
# 6. Counts consistency checks
# ------------------------------------------------------------------
counts_consistent <- function(df) {
  "
  Verifies that demographic counts sum to total_profiles for each
  offender type and category.
  "
  demo_sum <- df %>%
    filter(value_type == "count",
           variable_category != "total") %>%
    group_by(offender_type, variable_category) %>%
    summarise(sum_value = sum(value), .groups = "drop")
  
  totals <- df %>%
    filter(variable_category == "total",
           variable_detailed == "total_profiles",
           value_type == "count") %>%
    select(offender_type, value)
  
  merged <- demo_sum %>%
    left_join(totals, by = "offender_type") %>%
    mutate(diff = abs(sum_value - value))
  
  all(merged$diff < 1e-6)
}

# ------------------------------------------------------------------
# 7. Percentage consistency checks
# ------------------------------------------------------------------

percentages_consistent <- function(df) {
  "
  Verifies that derived or reported percentages sum to 100 ± 0.5 %.
  "
  result <- df %>%
    filter(value_type == "percentage") %>%
    group_by(offender_type, variable_category) %>%
    summarise(sum_value = sum(value), .groups = "drop") %>%
    mutate(consistent = abs(sum_value - 100) <= 0.5)
  
  all(result$consistent)
}


# ------------------------------------------------------------------
# 8. Report status for each category
# ------------------------------------------------------------------

# Define columns needed for foia_combined
report_status <- function(df, category) {
  values <- unique(df$value_type[df$variable_category == category])
  
  if (all(c("count", "percentage") %in% values)) {
    return("both")
  } else if ("count" %in% values) {
    return("counts")
  } else if ("percentage" %in% values) {
    return("percentages")
  } else {
    return("neither")
  }
}

# ------------------------------------------------------------------
# 9. Verify category totals
# ------------------------------------------------------------------

verify_category_totals <- function(df) {
  # 1 pull total_profiles per offender_type
  total_map <- df %>%
    filter(variable_category == "total", 
           variable_detailed == "total_profiles") %>%
    select(offender_type, value) %>%
    deframe() %>%
    as.list()
  
  # 2 sum counts by offender_type and variable_category
  demo_sum <- df %>%
    filter(value_type == "count",
           variable_category != "total") %>%
    group_by(offender_type, variable_category) %>%
    summarise(sum_counts = sum(value, na.rm = TRUE), .groups = "drop")
  
  # 3 attach total_profiles and compute difference
  demo_sum <- demo_sum %>%
    mutate(total_profiles = map_dbl(offender_type, ~total_map[[.x]]),
           difference = total_profiles - sum_counts)
  
  # tidy columns order
  demo_sum %>%
    select(offender_type, variable_category, total_profiles, 
           sum_counts, difference)
}

# ------------------------------------------------------------------
# 10. Calculate Combined totals
# ------------------------------------------------------------------

calculate_combined_totals <- function(df, state_name) {
  # Get all counts
  counts_df <- df %>%
    filter(value_type == 'count') %>%
    mutate(value_source = 'calculated')
  
  # Group by variable_category and variable_detailed, sum values
  combined_sums <- counts_df %>%
    group_by(variable_category, variable_detailed) %>%
    summarise(value = sum(value, na.rm = TRUE), .groups = "drop")
  
  # Create Combined rows
  combined_rows <- combined_sums %>%
    mutate(state = state_name,
           offender_type = 'Combined',
           value_type = 'count',
           value_source = 'calculated') %>%
    select(all_of(COLS_NEEDED), value_source)
  
  return(combined_rows)
}

# ------------------------------------------------------------------
# 11. Calculate percentages from counts
# ------------------------------------------------------------------

calculate_percentages <- function(df_combined, state_name) {
  # Get total profiles for each offender type
  totals_map <- df_combined %>%
    filter(state == state_name,
           variable_category == 'total',
           variable_detailed == 'total_profiles') %>%
    select(offender_type, value) %>%
    deframe() %>%
    as.list()
  
  percentage_rows <- list()
  
  for (offender_type in names(totals_map)) {
    total <- totals_map[[offender_type]]
    
    # Get all demographic counts
    demo_data <- df_combined %>%
      filter(state == state_name,
             offender_type == !!offender_type,
             variable_category %in% c('gender', 'race'),
             value_type == 'count')
    
    if (nrow(demo_data) > 0) {
      # Calculate percentage for each
      demo_percentages <- demo_data %>%
        mutate(value = round((value / total) * 100, 2),
               value_type = 'percentage',
               value_source = 'calculated') %>%
        select(all_of(COLS_NEEDED), value_source)
      
      percentage_rows <- c(percentage_rows, list(demo_percentages))
    }
  }
  
  bind_rows(percentage_rows)
}

# ------------------------------------------------------------------
# 12. Calculate counts from percentages
# ------------------------------------------------------------------

calculate_counts_from_percentages <- function(df_combined, state_name) {
  # Get total profiles for each offender type
  totals_map <- df_combined %>%
    filter(state == state_name,
           variable_category == 'total',
           variable_detailed == 'total_profiles') %>%
    select(offender_type, value) %>%
    deframe() %>%
    as.list()
  
  count_rows <- list()
  
  for (offender_type in names(totals_map)) {
    total <- totals_map[[offender_type]]
    
    # Get all demographic percentages
    demo_data <- df_combined %>%
      filter(state == state_name,
             offender_type == !!offender_type,
             variable_category %in% c('gender', 'race'),
             value_type == 'percentage')
    
    if (nrow(demo_data) > 0) {
      # Calculate count for each
      demo_counts <- demo_data %>%
        mutate(value = as.integer(round(total * (value / 100))),
               value_type = 'count',
               value_source = 'calculated') %>%
        select(all_of(COLS_NEEDED), value_source)
      
      count_rows <- c(count_rows, list(demo_counts))
    }
  }
  
  bind_rows(count_rows)
}

# ------------------------------------------------------------------
# 13. Standardize offender types
# ------------------------------------------------------------------

standardize_offender_types <- function(df) {
  replacements <- c(
    'Offenders' = 'Convicted Offender',
    'Convicted offenders' = 'Convicted Offender',
    'Arrested offender' = 'Arrestee',
    'All' = 'Combined'
  )
  
  df %>%
    mutate(offender_type = recode(offender_type, !!!replacements))
}

# ------------------------------------------------------------------
# 14. Prepare state data for combined dataset
# ------------------------------------------------------------------

prepare_state_for_combined <- function(df, state_name) {
  
  df_prepared <- df %>%
    select(any_of(COLS_NEEDED), value_source)
  
  df_prepared <- df_prepared %>%
      mutate(value_source = case_when(
        is.na(value_source) ~ "calculated",
        value_source == "" ~ "calculated",
        TRUE ~ value_source
      ))

  
  df_prepared
}

# ------------------------------------------------------------------
# 15. Compare reported vs calculated percentages
# ------------------------------------------------------------------

verify_percentage_consistency <- function(df_combined, state_name) {
  state_data <- df_combined %>%
    filter(state == state_name)
  
  # Get all offender types that have both counts and percentages
  offender_types <- unique(state_data$offender_type)
  
  consistency_results <- list()
  
  for (offender_type in offender_types) {
    offender_data <- state_data %>%
      filter(offender_type == !!offender_type)
    
    # Check if we have both reported and calculated percentages
    for (category in c('gender', 'race')) {
      reported_pcts <- offender_data %>%
        filter(variable_category == !!category,
               value_type == 'percentage',
               value_source == 'reported')
      
      calculated_pcts <- offender_data %>%
        filter(variable_category == !!category,
               value_type == 'percentage',
               value_source == 'calculated')
      
      if (nrow(reported_pcts) > 0 && nrow(calculated_pcts) > 0) {
        # Compare each demographic value
        for (i in 1:nrow(reported_pcts)) {
          rep_row <- reported_pcts[i, ]
          calc_match <- calculated_pcts %>%
            filter(variable_detailed == rep_row$variable_detailed)
          
          if (nrow(calc_match) > 0) {
            diff <- abs(rep_row$value - calc_match$value[1])
            consistency_results <- c(consistency_results, list(data.frame(
              offender_type = offender_type,
              category = category,
              variable = rep_row$variable_detailed,
              reported = rep_row$value,
              calculated = calc_match$value[1],
              difference = diff,
              consistent = diff < 0.5
            )))
          }
        }
      }
    }
  }
  
  if (length(consistency_results) > 0) {
    consistency_df <- bind_rows(consistency_results)
    cat(paste0("\nPercentage consistency check for ", state_name, ":\n"))
    cat(paste0("All values consistent: ", all(consistency_df$consistent), "\n"))
    
    if (!all(consistency_df$consistent)) {
      cat("\nInconsistent values:\n")
      print(consistency_df %>% filter(!consistent))
    }
    
    return(all(consistency_df$consistent))
  } else {
    # No comparison possible - state only has one type of data
    return(TRUE)
  }
}
# ------------------------------------------------------------------
# 16. Add compact formatting for large numbers
# ------------------------------------------------------------------

format_compact <- function(x) {
  sapply(x, function(single_x) {
    if (single_x >= 1000000) {
      if (single_x/1000000 == as.integer(single_x/1000000)) {
        return(paste0(as.integer(single_x/1000000), "M"))
      } else {
        return(paste0(round(single_x/1000000, 1), "M"))
      }
    } else if (single_x >= 1000) {
      return(paste0(as.integer(single_x/1000), "k"))
    } else {
      return(paste0(as.integer(single_x)))
    }
  })
}

# ------------------------------------------------------------------
# 17. Pie chart creation function
# ------------------------------------------------------------------

create_pie_chart <- function(data, offender_type, category, value_type, title, show_values = FALSE) {
  chart_data <- data %>%
    filter(offender_type == !!offender_type,
           variable_category == !!category,
           value_type == !!value_type)
  
  # Check if we have data after filtering
  if (nrow(chart_data) == 0) {
    plot.new()
    title(main = title, cex.main = 0.9)
    text(0.5, 0.5, "No data", cex = 0.8)
    return()
  }
  
  # AGGREGATE DATA TO REMOVE DUPLICATES - KEY FIX
  chart_data <- chart_data %>%
    group_by(variable_detailed) %>%
    summarise(value = sum(value, na.rm = TRUE)) %>%
    ungroup()
  
  # Ensure consistent categories
  if (category == 'gender') {
    all_genders <- data.frame(variable_detailed = c('Male', 'Female', 'Unknown'))
    chart_data <- chart_data %>%
      right_join(all_genders, by = "variable_detailed") %>%
      mutate(value = ifelse(is.na(value), 0, value)) %>%
      arrange(factor(variable_detailed, levels = c('Male', 'Female', 'Unknown')))
  } else if (category == 'race') {
    all_races <- data.frame(variable_detailed = c('White', 'Black', 'Hispanic', 
                                                 'Asian', 'Native American',
                                                  'Other', 'Unknown'))
    chart_data <- chart_data %>%
      right_join(all_races, by = "variable_detailed") %>%
      mutate(value = ifelse(is.na(value), 0, value)) %>%
      arrange(factor(variable_detailed, levels = c('White', 'Black', 'Hispanic', 
                                                  'Asian', 'Native American',
                                                   'Other', 'Unknown')))
  }
  
  # Filter out zero values and ensure we have data
  chart_data <- chart_data %>% filter(value > 0)
  
  if (nrow(chart_data) == 0) {
    plot.new()
    title(main = title, cex.main = 0.9)
    text(0.5, 0.5, "No data", cex = 0.8)
    return()
  }
  
  # Define colors
  if (category == 'gender') {
    colors <- c('Male' = '#4E79A7', 'Female' = '#E15759', 'Unknown' = '#BAB0AC')
  } else {
    colors <- c('White' = '#4E79A7', 'Black' = '#F25E2B', 'Hispanic' = '#E14759',
               'Asian' = '#76B7B2', 'Native American' = '#59A14F',
               'Other' = '#9C755F', 'Unknown' = '#BAB0AC')
  }
  
  # Filter colors to only include categories present in data
  pie_colors <- colors[names(colors) %in% chart_data$variable_detailed]
  
  # Calculate percentages
  total_value <- sum(chart_data$value)
  chart_data <- chart_data %>%
    mutate(pct = value / total_value * 100)
  
  # Create labels based on value_type and show_values
  if (show_values && value_type == 'count') {
    chart_data <- chart_data %>%
      mutate(base_label = paste0(variable_detailed, "\n(",
      format(value, big.mark = ","), ")"))
  } else if (value_type == 'percentage') {
    chart_data <- chart_data %>%
      mutate(base_label = paste0(variable_detailed, "\n(", round(value, 1), "%)"))
  } else {
    chart_data <- chart_data %>%
      mutate(base_label = variable_detailed)
  }
  
  # Only show labels for slices >= 3%, otherwise empty string
  chart_data <- chart_data %>%
    mutate(label = ifelse(pct >= 3, base_label, ""))
  
  # Create the pie chart
  pie(chart_data$value, 
      labels = chart_data$label,
      main = title,
      col = pie_colors,
      cex.main = 0.9,
      cex = 0.8)
  
  # Add legend for small slices
  small_slices <- chart_data %>% filter(pct < 3)
  if (nrow(small_slices) > 0) {
    legend_labels <- paste0(small_slices$variable_detailed, " (",
     round(small_slices$pct, 1), "%)")
    legend_colors <- pie_colors[small_slices$variable_detailed]
    
    legend("bottomright", 
           legend = legend_labels,
           fill = legend_colors,
           cex = 0.7,
           bty = "n")
  }
}

# ------------------------------------------------------------------
# 18. State visualizations with 2 pies per row
# ------------------------------------------------------------------

create_state_visualizations <- function(df_combined, state_name) {
  state_data <- df_combined %>% filter(state == state_name)
  
  offender_types <- sort(unique(state_data$offender_type))
  plots <- list()
  
  for (offender_type in offender_types) {
    plots <- c(plots, list(
      create_pie_chart(state_data, offender_type, 'gender', 'count',
                       paste(offender_type, "Gender Counts"), TRUE),
      create_pie_chart(state_data, offender_type, 'gender', 'percentage',
                       paste(offender_type, "Gender Percentages")),
      create_pie_chart(state_data, offender_type, 'race', 'count',
                       paste(offender_type, "Race Counts"), TRUE),
      create_pie_chart(state_data, offender_type, 'race', 'percentage',
                       paste(offender_type, "Race Percentages"))
    ))
  }
}

# ------------------------------------------------------------------
# 19. Demographic bar chart function
# ------------------------------------------------------------------

create_demographic_bar_charts <- function(df_combined, state_name) {
  state_data <- df_combined %>%
    filter(state == state_name)
  
  # Get offender types and ensure Combined is last
  offender_types <- state_data %>%
    filter(value_type == 'count') %>%
    pull(offender_type) %>%
    unique() %>%
    sort()
  
  if ('Combined' %in% offender_types) {
    offender_types <- c(setdiff(offender_types, 'Combined'), 'Combined')
  }
  
  # Color palettes
  gender_colors <- c('Male' = '#4E79A7', 'Female' = '#E15759',
  'Unknown' = '#BAB0AC')
  race_colors <- c(
    'White' = '#4E79A7', 
    'Black' = '#F25E2B', 
    'Hispanic' = '#E14759',
    'Asian' = '#76B7B2',
    'Native American' = '#59A14F',
    'Other' = '#9C755F',
    'Unknown' = '#BAB0AC'
  )
  
  # Gender data - ensure no duplicates by summing values
  gender_data <- state_data %>%
    filter(variable_category == 'gender',
           value_type == 'count') %>%
    group_by(offender_type, variable_detailed) %>%
    summarize(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
    complete(offender_type, variable_detailed = c('Male', 'Female', 'Unknown'), 
             fill = list(value = 0))
  
  # Race data - ensure no duplicates by summing values
  race_data <- state_data %>%
    filter(variable_category == 'race',
           value_type == 'count') %>%
    group_by(offender_type, variable_detailed) %>%
    summarize(value = sum(value, na.rm = TRUE), .groups = 'drop') %>%
    complete(offender_type, 
             variable_detailed = c('White', 'Black', 'Hispanic', 
                                  'Asian', 'Native American', 'Other', 'Unknown'), 
             fill = list(value = 0))
  
  # Create separate plots - one per row
  par(mfrow = c(2, 1), mar = c(5, 9, 4, 9), oma = c(0, 0, 2, 0))
  
  # Gender plot - ordered by total volume
  gender_plot_data <- gender_data %>%
    filter(variable_detailed %in% c('Male', 'Female', 'Unknown')) %>%
    mutate(offender_type = factor(offender_type, levels = rev(offender_types)))
  
  # Order gender categories by total volume (largest at bottom)
  gender_order <- gender_plot_data %>%
    group_by(variable_detailed) %>%
    summarize(total = sum(value)) %>%
    arrange(total) %>%
    pull(variable_detailed)
  
  gender_plot_data <- gender_plot_data %>%
    mutate(variable_detailed = factor(variable_detailed, levels = gender_order))
  
  # Reshape for barplot
  gender_matrix <- gender_plot_data %>%
    pivot_wider(names_from = variable_detailed, values_from = value) %>%
    as.data.frame() %>%
    column_to_rownames("offender_type") %>%
    as.matrix()
  
  # Ensure all columns exist
  for (gender in gender_order) {
    if (!gender %in% colnames(gender_matrix)) {
      gender_matrix <- cbind(gender_matrix, temp = 0)
      colnames(gender_matrix)[ncol(gender_matrix)] <- gender
    }
  }
  
  # Reorder columns by volume
  gender_matrix <- gender_matrix[, as.character(gender_order), drop = FALSE]
  
  # Format x-axis labels with "k" for thousands
  max_x <- max(rowSums(gender_matrix))
  x_breaks <- pretty(c(0, max_x))
  x_labels <- ifelse(x_breaks >= 1000, 
                    paste0(x_breaks/1000, "k"), 
                    as.character(x_breaks))
  
  barplot(t(gender_matrix), 
          horiz = TRUE,
          las = 1,
          col = gender_colors[colnames(gender_matrix)],
          main = 'Gender Distribution',
          xlab = 'Number of Profiles',
          xaxt = 'n',  # Remove default x-axis
          legend.text = FALSE,  # Don't show legend in plot area
          args.legend = list(x = "right", bty = "n", inset = c(-0.2, 0)))
  
  # Add custom x-axis with formatted labels
  axis(1, at = x_breaks, labels = x_labels)
  
  # Add legend outside the plot area
  legend("topright", 
         legend = colnames(gender_matrix), 
         fill = gender_colors[colnames(gender_matrix)],
         bty = "n", 
         xpd = TRUE,  # Allow plotting outside main area
         inset = c(-0.25, 0),  # Move legend to the right
         cex = 0.8)
  
  # Race plot - ordered by total volume
  race_plot_data <- race_data %>%
    mutate(offender_type = factor(offender_type, levels = rev(offender_types)))
  
  # Order race categories by total volume (largest at bottom)
  race_order <- race_plot_data %>%
    group_by(variable_detailed) %>%
    summarize(total = sum(value)) %>%
    arrange(total) %>%
    pull(variable_detailed)
  
  race_plot_data <- race_plot_data %>%
    mutate(variable_detailed = factor(variable_detailed, levels = race_order))
  
  # Reshape for barplot
  race_matrix <- race_plot_data %>%
    pivot_wider(names_from = variable_detailed, values_from = value) %>%
    as.data.frame() %>%
    column_to_rownames("offender_type") %>%
    as.matrix()
  
  # Ensure all columns exist
  for (race in race_order) {
    if (!race %in% colnames(race_matrix)) {
      race_matrix <- cbind(race_matrix, temp = 0)
      colnames(race_matrix)[ncol(race_matrix)] <- race
    }
  }
  
  # Reorder columns by volume
  race_matrix <- race_matrix[, as.character(race_order), drop = FALSE]
  
  # Format x-axis labels with "k" for thousands
  max_x_race <- max(rowSums(race_matrix))
  x_breaks_race <- pretty(c(0, max_x_race))
  x_labels_race <- ifelse(x_breaks_race >= 1000, 
                         paste0(x_breaks_race/1000, "k"), 
                         as.character(x_breaks_race))
  
  barplot(t(race_matrix), 
          horiz = TRUE,
          las = 1,
          col = race_colors[colnames(race_matrix)],
          main = 'Race Distribution',
          xlab = 'Number of Profiles',
          xaxt = 'n',  # Remove default x-axis
          legend.text = FALSE)  # Don't show legend in plot area
  
  # Add custom x-axis with formatted labels
  axis(1, at = x_breaks_race, labels = x_labels_race)
  
  # Add legend outside the plot area
  legend("topright", 
         legend = colnames(race_matrix), 
         fill = race_colors[colnames(race_matrix)],
         bty = "n", 
         xpd = TRUE,  # Allow plotting outside main area
         inset = c(-0.25, 0),  # Move legend to the right
         cex = 0.8)
  
  title(paste(state_name, "Demographic Distribution"),
   outer = TRUE, cex.main = 1.5)
}

# ------------------------------------------------------------------
# 20. Add state's metadata
# ------------------------------------------------------------------

add_state_metadata <- function(state_name, state_df) {
  
  raw_data <- state_df %>% filter(value_source == "reported")
  offender_types_reported <- unique(raw_data$offender_type)
  
  has_unknown <- any(raw_data$variable_detailed == "Unknown", na.rm = TRUE)
  has_other <- any(raw_data$variable_detailed == "Other", na.rm = TRUE)
  has_crosstab <- any(raw_data$variable_category == "gender_race", na.rm = TRUE)
  
  nonstandard_terms <- any(
    grepl("All|Offenders", raw_data$offender_type, ignore.case = TRUE),
    grepl("Caucasian|African American| American Indian", 
    raw_data$variable_detailed, ignore.case = TRUE),
    grepl("flag", raw_data$variable_detailed, ignore.case = TRUE))
  
  new_row <- tibble(
    state = state_name,
    race_data_provided = report_status(raw_data, "race"),
    gender_data_provided = report_status(raw_data, "gender"),
    total_profiles_provided = report_status(
      raw_data %>% filter(variable_category == "total"), "total"
    ),
    convicted_offender_reported = "Convicted Offender" %in% offender_types_reported,
    arrestee_reported = "Arrestee" %in% offender_types_reported,
    combined_reported = "Combined" %in% offender_types_reported,
    has_unknown_category = has_unknown,
    has_other_category = has_other,
    uses_nonstandard_terminology = nonstandard_terms,
    provides_crosstabulation = has_crosstab,
    counts_sum_to_total = NA,
    percentages_sum_to_100 = NA,
    total_calculated_combined = !("Combined" %in% offender_types_reported),
    notes = ""
  )
  
  foia_state_metadata <<- bind_rows(foia_state_metadata, new_row)
  
  cat("✓ Metadata added for:", state_name, "\n")
  return(invisible(TRUE))
}

# ------------------------------------------------------------------
# 21. Function to update a state's metadata after QC checks
# ------------------------------------------------------------------
update_state_metadata <- function(state_name, 
                                  counts_ok = NA, 
                                  percentages_ok = NA, 
                                  notes_text = NULL) {
  
  row_index <- which(foia_state_metadata$state == state_name)
  
  if (length(row_index) == 0) {
    warning("State not found in metadata: ", state_name)
    return(FALSE)
  }
  
  if (!is.na(counts_ok)) {
    foia_state_metadata$counts_sum_to_total[row_index] <<- counts_ok
  }
  if (!is.na(percentages_ok)) {
    foia_state_metadata$percentages_sum_to_100[row_index] <<- percentages_ok
  }
  if (!is.null(notes_text)) {
    current_notes <- foia_state_metadata$notes[row_index]
    if (current_notes == "") {
      foia_state_metadata$notes[row_index] <<- notes_text
    } else {
      foia_state_metadata$notes[row_index] <<- paste(current_notes,
       notes_text, sep = "; ")
    }
  }
  
  cat("✓ Metadata updated for:", state_name, "\n")
}

```

## File Structure and Contents

### State-Specific Files: `data/foia/intermediate/[state]_foia_data.csv`

**Purpose**: Individual files for each state containing only their
reported data.

**Structure**: Long format with columns:

-   `state`: State name
-   `offender_type`: Category of individuals (Convicted Offender,
    Arrestee, Combined, etc.)
-   `variable_category`: Type of data (total, gender, race, gender_race)
-   `variable_detailed`: Specific value (e.g., Male, Female, African
    American)
-   `value`: The reported number or percentage
-   `value_type`: Whether value is a "count" or "percentage"
-   `date`: Date of data snapshot, if reported

```{r}
#| label: load-per-state-files
#| echo: true

## Per-state files loading code --

ca_raw <- load_state(here(per_state, "california_foia_data.csv"))
fl_raw <- load_state(here(per_state, "florida_foia_data.csv"))
in_raw <- load_state(here(per_state, "indiana_foia_data.csv"))
me_raw <- load_state(here(per_state, "maine_foia_data.csv"))
nv_raw <- load_state(here(per_state, "nevada_foia_data.csv"))
sd_raw <- load_state(here(per_state, "south_dakota_foia_data.csv"))
tx_raw <- load_state(here(per_state, "texas_foia_data.csv"))

```

\forcebreak

### Raw Data Characteristics

The following table summarizes the structure and content of the data as
originally received from each state prior to any standardization,
calculation, or processing.

| State | Offender Types | Value Types | Total Profiles | Action Needed | Key Reporting Notes |
|:-----------|:-----------|:-----------|:-----------|:-----------|:-----------|
| **California** | CO, A | Counts only | Reported per offender type | Add Unknown Race, Calculate % & Combined, Standardize Terminology | Discrepancy in Race: counts \< total profiles; Non-standard terminology (Caucasian and African American) |
| **Florida** | COMB | Counts + % | Reported | Standardize Terminology | Non-standard terminology (Caucasian and African American) |
| **Indiana** | CO, A, COMB | Percentage (Counts for totals only) | Reported per offender type | Calculate Counts & Total Profiles Combined, Fix % inconsistency, Standardize Terminology | Demographics only for Combined; `Other` race category as "<1"; Non-standard terminology (Caucasian) |
| **Maine** | COMB | Counts + % | Reported | Solve counts and Percentage inconsistency |  |
| **Nevada** | CO, A, COMB | Counts + % | Reported for all types | Standardize Terminology | Non-standard terminology (All, total_flags and American Indian) |
| **South Dakota** | COMB | Counts + % | Reported | Standardize Terminology, Solve counts and % inconsistency | Includes gender×race cross-tabulation; Non-standard terminology |
| **Texas** | CO, A | Counts only | Reported per offender type | Calculate Male counts, Solve counts inconsistency, Calculate % & Combined, Standardize Terminology| Only female gender was reported; Non-standard term (Offenders, Caucasian, and African American) |

**Legend:**

-   **CO:** Convicted Offender

-   **AR:** Arrestee

-   **COMB:** Combined Total (all profiles)

-   **Counts + %:** Both raw numbers and percentages were provided

## Prepare Combined Dataset

The goal of this step is to transform each state's raw data into a
standardized format before appending it to the master `foia_combined`
DataFrame. This ensures consistency and enables seamless analysis across
all seven states.

The ideal, standardized state dataset ready for combination must have
the following columns:

| Column Name | Description | Example Values |
|:-----------------------|:-----------------------|:-----------------------|
| **`state`** | The name of the state. | `"California"`, `"Florida"` |
| **`offender_type`** | The category of offender profile. | `"Convicted Offender"`, `"Arrestee"`, `"Combined"` |
| **`variable_category`** | The broad demographic category. | `"race"`, `"gender"`, `"total"`, `"gender_race"` |
| **`variable_detailed`** | The specific value within the category. | `"White"`, `"Male"`, `"total_profiles"`, `"Male_White"` |
| **`value`** | The numerical value for the metric. | `150000`, `25.8` |
| **`value_type`** | The type of metric the value represents. | `"count"`, `"percentage"` |
| **`value_source`** | Whether the data was provided or derived. | `"reported"`, `"calculated"` |

```{r}
#| label: init-foia-combined
#| echo: true
#| warning: false
#| message: false

## Master foia_combined dataframe--

foia_combined <- tibble( state = character(),
offender_type = character(),
variable_category = character(),
variable_detailed = character(), 
value = numeric(),
value_type = character(),
value_source = character()
)
```

```{r}
#| echo: false

# Create a data dictionary for foia_combined
schema_dict <- tribble(
  ~Column,             ~Type,        ~Description, 
  "state",             "character",  "'California', 'Florida'",
  "offender_type",     "character",  "'Convicted Offender', 'Arrestee', 'Combined'",
  "variable_category", "character",  "'race', 'gender', 'total', 'gender_race'",
  "variable_detailed", "character",  "'White', 'Male', 'total_profiles', 'Male_White'",
  "value",             "numeric",    "150000, 25.8",
  "value_type",        "character",  "'count', 'percentage'",
  "value_source",      "character",  "'reported', 'calculated'"
)

# Turn into a nice flextable
flextable(schema_dict) %>%
  autofit() %>%
  theme_booktabs() %>%
  set_header_labels(
    Column = "Column Name",
    Type = "Data Type",
    Description = "Example Values to be added"
  )

```

## Prepare Metadata Documentation Table

This section creates a comprehensive metadata table
(**`foia_state_metadata`**) to document the original content and
structure of each state's FOIA response *before* any processing or
cleaning was applied.

This serves as a permanent record of data provenance, ensuring
transparency and reproducibility by clearly distinguishing between what
was *provided* by the states and what was *calculated* during analysis.

**Key Documentation Captured:**

-   **Data Types Provided:** Whether each state reported counts,
    percentages, or both for race, gender, and total profiles.

-   **Offender Categories Reported:** Which offender types (Convicted
    Offender, Arrestee, Combined) were originally included.

-   **Demographic Granularity:** Presence of 'Unknown' or 'Other'
    categories and gender-race cross-tabulations.

-   **Terminology & Anomalies:** Use of non-standard terms (e.g.,
    "flags," "offenders") and other state-specific reporting notes.

-   **QC Results:** Flags for whether cleaned data passes consistency
    checks (counts sum to totals, percentages sum to \~100%).

```{r}
#| label: create-metadata-table
#| echo: true
#| warning: false
#| results: hold
#| message: false

## foia_state_metadata table elaboration code --

# Define the full schema for our metadata table
foia_state_metadata <- tibble(
  state = character(),
  race_data_provided = character(),
  gender_data_provided = character(),
  total_profiles_provided = character(), 
  convicted_offender_reported = logical(),
  arrestee_reported = logical(),
  combined_reported = logical(),
  has_unknown_category = logical(),
  has_other_category = logical(),
  uses_nonstandard_terminology = logical(),
  provides_crosstabulation = logical(),
  counts_sum_to_total = logical(),
  percentages_sum_to_100 = logical(),
  total_calculated_combined = logical(),
  notes = character()
)

```

```{r}
#| echo: false

# Build data dictionary for foia_state_metadata
schema_dict_meta <- tribble(
  ~Column,                        ~Type,       ~Description,
  "state",                        "character", "State name (e.g., 'California', 'Florida')",
  "race_data_provided",           "character", "Race data availability: 'counts', 'percentages', 'both'",
  "gender_data_provided",         "character", "Gender data availability: 'counts', 'percentages', 'both'",
  "total_profiles_provided",      "character", "Total profiles availability: 'counts', 'percentages', 'both'",
  "convicted_offender_reported",  "logical",   "Was convicted offender data reported?",
  "arrestee_reported",            "logical",   "Was arrestee data reported?",
  "combined_reported",            "logical",   "Was combined category reported?",
  "has_unknown_category",         "logical",   "Does the state include 'Unknown' category?",
  "has_other_category",           "logical",   "Does the state include 'Other' category?",
  "uses_nonstandard_terminology", "logical",   "Does the state use non-standard terms?",
  "provides_crosstabulation",     "logical",   "Does the state provide crosstabs (e.g., gender x race)?",
  "counts_sum_to_total",          "logical",   "Do reported counts sum to the total?",
  "percentages_sum_to_100",       "logical",   "Do reported percentages sum to ~100%?",
  "total_calculated_combined",    "logical",   "Did we calculate combined total manually?",
  "notes",                        "character", "Free-text notes for state-specific caveats"
)

# Render with flextable
flextable(schema_dict_meta) %>%
  autofit() %>%
  theme_booktabs() %>%
  set_header_labels(
    Column = "Column Name",
    Type = "Data Type",
    Description = "Meaning"
  )

```

# State-by-state Standardization

Each state is processed individually to standardize terminology, fill
gaps, and calculate Combined totals where necessary.

## California (CA)

**Overview**: California supplies **counts only** for gender and race
plus a separate total for each offender type; no percentages are
reported.

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: ca-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(ca_raw)
```

### Verify Data Consistency

Runs the first quality check using the **`verify_category_totals()`**
and **`counts_consistent()`** functions.

This identifies any immediate discrepancies, such as the sum of
demographic counts not matching the reported total profiles, which flags
data issues that need to be resolved.

```{r}
#| label: ca-verify-raw
#| echo: false

# Check if raw counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
ca_category_qc <- verify_category_totals(ca_raw)
ca_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check on raw data:\n")
cat(paste("All counts consistent:", counts_consistent(ca_raw), "\n"))
```

### Address Data Gaps

#### Create Unknown Category

> *"Racial classification is not considered a required field on the
> collection card; thus, an unknown number of offenders may have **no
> racial classification listed**."* — California DOJ FOIA letter, July
> 10 2018 (**`raw/foia_pdfs/FOIA_RacialComp_California.pdf`**)

The 393,887 Convicted Offender profiles and 96,127 Arrestee profiles
that do **not** appear in any of the four reported race categories must
belong to an unreported "Unknown" category.

The calculated values are added with a **`value_source = "calculated"`**
tag to maintain transparency about what was provided versus what was
derived.

```{r}
#| label: ca-add-unknown
#| echo: false
#| results: hold

# Start with the raw data
ca_clean <- ca_raw

# Add Unknown race category to reconcile totals
ca_clean <- fill_demographic_gaps(ca_clean)

# Verify the fix
cat("Category totals after adding Unknown race category:\n")
verify_category_totals(ca_clean) %>% kable() %>% kable_styling()

cat("\nCounts consistency after adding Unknown:\n")
cat(paste("All counts consistent:", counts_consistent(ca_clean), "\n"))
```

#### Create Combined Totals

Since California only reported data for "Convicted Offender" and
"Arrestee" separately.

This step uses the **`add_combined()`** helper function to calculate a
new "Combined" offender type by summing the counts from the other two
categories.

```{r}
#| label: ca-create-combined
#| echo: false
#| results: hold

# Calculate Combined totals using helper function
ca_clean <- add_combined(ca_clean)

cat("✓ Created Combined totals for California\n")

# Show the Combined total
combined_total <- ca_clean %>%
  filter(offender_type == "Combined",
         variable_category == "total",
         variable_detailed == "total_profiles") %>%
  pull(value)

cat(paste("Combined total profiles:", format(combined_total, big.mark = ","), "\n"))
```

#### Calculate Percentages

Transforms the data from counts into percentages for comparative
analysis.

The **`add_percentages()`** helper function calculates each demographic
group's proportion relative to its offender type's total.

A final consistency check ensures all percentages logically sum to
approximately 100%.

```{r}
#| label: ca-calculate-percentages
#| echo: false
#| results: hold

# Derive percentages from counts
ca_clean <- add_percentages(ca_clean)

cat("✓ Added percentages for all demographic categories\n")

# Check percentage consistency
cat("Percentage consistency check:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(ca_clean), "\n\n"))

# Show current data availability
cat("Final data availability:\n")
cat(paste("Race data:", report_status(ca_clean, "race"), "\n"))
cat(paste("Gender data:", report_status(ca_clean, "gender"), "\n"))
```

#### Standardize Terminology

California uses "African American" instead of "Black" and "Caucasian"
instead of "White".

```{r}
#| label: ca-standardize-terminology
#| echo: false
#| results: hold

# Standardize racial terminology
ca_clean <- ca_clean %>%
  mutate(variable_detailed = case_when(
    variable_detailed == "African American" ~ "Black",
    TRUE ~ variable_detailed
  ))

cat("✓ Standardized terminology: 'African American' → 'Black'\n")

ca_clean <- ca_clean %>%
  mutate(variable_detailed = case_when(
    variable_detailed == "Caucasian" ~ "White",
    TRUE ~ variable_detailed
  ))

cat("✓ Standardized terminology: 'Caucasian' → 'White'\n")
```

### Prepare for Combined Dataset

The cleaned data is formatted to match the master schema and appended to
the `foia_combined` dataframe.

```{r}
#| label: ca-prepare-combined
#| echo: false
#| results: hold

# Prepare the cleaned data for the combined dataset
ca_prepared <- prepare_state_for_combined(ca_clean, "California")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, ca_prepared)

cat(paste0("✓ Appended ", nrow(ca_prepared), " California rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))
```

### Document Metadata

The metadata is added with the raw information and updated with the
results of the quality checks and a note on the processing steps taken.

```{r}
#| label: ca-prepare-metadata
#| echo: false
#| results: hold

# Add California to the metadata table using the helper function
add_state_metadata("California", ca_raw)

# Update metadata with QC results
update_state_metadata("California", 
                      counts_ok = counts_consistent(ca_clean),
                      percentages_ok = percentages_consistent(ca_clean),
                      notes_text = "Added Unknown race category to reconcile totals; calculated Combined totals and all percentages")

```

### Visualizations

```{r}
#| label: ca-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "California DNA Database Demographic Distributions"
#| warning: false
#| message: false

create_state_visualizations(foia_combined, "California")
```

```{r}
#| label: ca-bar-charts
#| echo: false
#| fig-width: 8
#| fig-height: 12
#| fig-cap: "California Demographic Distributions by Offender Type"

create_demographic_bar_charts(foia_combined, "California")
```

### Summary Statistics

```{r}
#| label: ca-summary
#| echo: false
#| results: hold

cat("California DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "California",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value) %>%
  mutate(value_formatted = format(value, big.mark = ","))

cat("### Total Profiles by Offender Type (California)\n\n")
totals %>%
  select(offender_type, value_formatted) %>%
  rename(`Offender Type` = offender_type,
         `Total Profiles` = value_formatted) %>%
  kable(align = c("l", "r"), 
        format.args = list(big.mark = ","))

# Data completeness
cat("\n\n### Data Completeness by Source\n\n")
completeness <- foia_combined %>%
  filter(state == "California") %>%
  group_by(offender_type, value_source) %>%
  summarise(n_values = n(), .groups = "drop") %>%
  arrange(offender_type, value_source)

completeness %>%
  rename(`Offender Type` = offender_type,
         `Value Source` = value_source,
         `Number of Values` = n_values) %>%
  kable(align = c("l", "l", "r"))

# Final verification
cat("\n\n### Data Validation Summary\n\n")
validation_results <- data.frame(
  Check = c("Counts Consistency", "Percentages Consistency"),
  Status = c(
    ifelse(counts_consistent(foia_combined %>% filter(state == "California")), 
           "✓ Pass", "✗ Fail"),
    ifelse(percentages_consistent(foia_combined %>% filter(state == "California")), 
           "✓ Pass", "✗ Fail")
  )
)

kable(validation_results, align = c("l", "c"))
```

### Summary of California Processing

California data processing complete. The dataset now includes:

-   ✅ **Reported data**: Counts for Convicted Offender and Arrestee

-   ✅ **Calculated additions**:

    -   Unknown race category to reconcile reported totals

    -   Combined totals across all offender types

    -   Percentage values for all demographic categories

    -   "Caucasian" and "African American" converted to "White" and
        "Black".

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation

-   ✅ **Provenance tracking**: All values include appropriate
    **`value_source`** indicators

The California data is now standardized and ready for cross-state
analysis.

## Florida (FL)

**Overview**: Florida provides **both counts and percentages** for
gender and race categories and already includes a "Combined" total for
all offender types, making it one of the most complete and
straightforward datasets.

Only requires to standardize terminology for gender and race categories
to match the common data model.

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: fl-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(fl_raw)
```

### Verify Data Consistency

Runs the first quality check using the **`Verify_category_totals()`**
and **`counts_consistent()`** functions.

```{r}
#| label: fl-verify-raw
#| echo: false

# Check if raw counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
fl_category_qc <- verify_category_totals(fl_raw)
fl_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check on raw data:\n")
cat(paste("All counts consistent:", counts_consistent(fl_raw), "\n"))

cat("\nPercentage consistency check on raw data:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(fl_raw), "\n"))
```

### Address Data Gaps

#### Standardize Terminology

Florida uses "African American" instead of "Black" and "Caucasian"
instead of "White".

```{r}
#| label: fl-standardize-terminology
#| echo: false
#| results: hold

fl_clean <- fl_raw

# Standardize racial terminology
fl_clean <- fl_clean %>%
  mutate(variable_detailed = case_when(
    variable_detailed == "African American" ~ "Black",
    TRUE ~ variable_detailed
  ))

cat("✓ Standardized terminology: 'African American' → 'Black'\n")

fl_clean <- fl_clean %>%
  mutate(variable_detailed = case_when(
    variable_detailed == "Caucasian" ~ "White",
    TRUE ~ variable_detailed
  ))

cat("✓ Standardized terminology: 'Caucasian' → 'White'\n")
```

### Prepare for Combined Dataset

The Florida data is already complete and consistent. It is formatted to
match the master schema and appended to the `foia_combined` dataframe.

```{r}
#| label: fl-prepare-combined
#| echo: false
#| results: hold

# Prepare the data for the combined dataset
fl_prepared <- prepare_state_for_combined(fl_clean, "Florida")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, fl_prepared)

cat(paste0("✓ Appended ", nrow(fl_prepared), " Florida rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))
```

### Document Metadata

The metadata is added with a note that the data was complete and
required no processing.

```{r}
#| label: fl-prepare-metadata
#| echo: false
#| results: hold

# Add Florida to the metadata table using the helper function
add_state_metadata("Florida", fl_raw)

# Update metadata with QC results
update_state_metadata("Florida", 
                      counts_ok = counts_consistent(fl_clean),
                      percentages_ok = percentages_consistent(fl_clean),
                      notes_text = "Complete dataset provided. No processing or calculations required. All values are reported.")
```

### Visualizations

```{r}
#| label: fl-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "Florida DNA Database Demographic Distributions"
#| warning: false
#| message: false

create_state_visualizations(foia_combined, "Florida")
```

### Summary Statistics

```{r}
#| label: fl-summary
#| echo: false
#| results: hold

cat("Florida DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "Florida",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value) %>%
  mutate(value_formatted = format(value, big.mark = ","))

cat("### Total Profiles by Offender Type (Florida)\n\n")
totals %>%
  select(offender_type, value_formatted) %>%
  rename(`Offender Type` = offender_type,
         `Total Profiles` = value_formatted) %>%
  kable(align = c("l", "r"))

# Data completeness
cat("\n\n### Data Completeness by Source\n\n")
completeness <- foia_combined %>%
  filter(state == "Florida") %>%
  group_by(offender_type, value_source) %>%
  summarise(n_values = n(), .groups = "drop") %>%
  arrange(offender_type, value_source)

completeness %>%
  rename(`Offender Type` = offender_type,
         `Value Source` = value_source,
         `Number of Values` = n_values) %>%
  kable(align = c("l", "l", "r"))

# Final verification
cat("\n\n### Data Validation Summary\n\n")
validation_results <- data.frame(
  Check = c("Counts Consistency", "Percentages Consistency"),
  Status = c(
    ifelse(counts_consistent(foia_combined %>% filter(state == "Florida")), 
           "✓ Pass", "✗ Fail"),
    ifelse(percentages_consistent(foia_combined %>% filter(state == "Florida")), 
           "✓ Pass", "✗ Fail")
  )
)

kable(validation_results, align = c("l", "c"))
```

### Summary of Florida Processing

Florida data processing complete. The dataset is exemplary and required
no adjustments:

-   ✅ **Reported data**: Both **counts and percentages** for all
    Convicted Offender, Arrestee, and Combined categories.

-   ✅ **Terminology standardization**: "Caucasian" and "African
    American" converted to "White" and "Black".

-   ✅ **No calculated additions needed**: All values are sourced
    directly from the state report (**`value_source = "reported"`**).

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation.

-   ✅ **Provenance tracking**: All values maintain their original
    **`value_source`** as "reported".

The Florida data is now standardized and ready for cross-state analysis.

## Indiana (IN)

**Overview**: Indiana presents a unique reporting pattern where total
counts are provided by offender type, but demographic breakdowns are
given only as percentages for the Combined total.

Values were provided as strings, including a "\<1" notation, requiring
conversion.

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: in-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(in_raw)
```

### Verify Data Consistency

Initial checks reveal Indiana's unique structure: counts for totals,
percentages only for Combined demographics.

```{r}
#| label: in-verify-raw
#| echo: false

# Check what data is available
cat("Initial data availability:\n")
cat(paste("Race data:", report_status(in_raw, "race"), "\n"))
cat(paste("Gender data:", report_status(in_raw, "gender"), "\n"))

# Check value types present
cat("\nValue types in raw data:\n")
in_raw %>%
  distinct(value_type) %>%
  pull() %>%
  paste(collapse = ", ") %>%
  cat()
```

### Address Data Gaps

#### Convert String Values to Numeric

The raw data contains string values including "\<1" which we convert to
0.5.

```{r}
#| label: in-convert-values
#| echo: false
#| results: hold

# Start with raw data
in_clean <- in_raw

# Convert string values to numeric, handling "<1" as 1
in_clean$value <- sapply(in_clean$value, function(x) {
  if (x == "<1") {
    0.5
  } else {
    as.numeric(x)
  }
})

# Update value_type for converted percentages
in_clean <- in_clean %>%
  mutate(value_type = ifelse(value_type == "percentage", "percentage", value_type))

cat("✓ Converted Indiana values from String to numeric\n")
cat(paste("Unique values after conversion:", paste(unique(in_clean$value), collapse = ", "), "\n"))
```

#### Solve Percentages Inconsistency

Racial percentages summed to 100.5% instead of 100%

Proportional scaling was applied and `value_source` was updated to "calculated" for all adjusted values.

```{r}
#| label: in-recalculate-percentages
#| echo: false
#| results: hold

# Adjust percentages to ensure they sum to 100% and mark as calculated
in_clean <- in_clean %>%
  group_by(value_type, variable_category) %>%
  mutate(
    value = ifelse(
      value_type == "percentage" & variable_category == "race",
      value * (100 / sum(value, na.rm = TRUE)),
      value
    ),
    value_source = ifelse(
      value_type == "percentage" & variable_category == "race",
      "calculated",
      value_source
    )
  ) %>%
  ungroup()

# Verify the new sum
percentage_sum <- in_clean %>%
  filter(value_type == "percentage" & variable_category == "race") %>%
  summarise(total = sum(value, na.rm = TRUE))

cat("✓ Recalculated percentages for Indiana - New sum:", percentage_sum$total, "%\n")
```

#### Standardize Terminology

Indiana uses "Caucasian" instead of "White".

```{r}
#| label: in-standardize-terminology
#| echo: false
#| results: hold

# Standardize racial terminology
in_clean <- in_clean %>%
  mutate(variable_detailed = case_when(
    variable_detailed == "Caucasian" ~ "White",
    TRUE ~ variable_detailed
  ))

cat("✓ Standardized terminology: 'Caucasian' → 'White'\n")
```

#### Create Combined Total Profiles

Indiana provides separate totals for Convicted Offenders and Arrestees,
but we need a Combined total to match the demographic percentages.

```{r}
#| label: in-create-combined-total
#| echo: false
#| results: hold

# Calculate Combined total from separate offender type totals
convicted_total <- in_clean %>%
  filter(offender_type == "Convicted Offender",
         variable_category == "total",
         variable_detailed == "total_profiles") %>%
  pull(value)

arrestee_total <- in_clean %>%
  filter(offender_type == "Arrestee",
         variable_category == "total",
         variable_detailed == "total_profiles") %>%
  pull(value)

combined_total <- convicted_total + arrestee_total

# Add Combined total to the data
combined_row <- data.frame(
  state = "Indiana",
  offender_type = "Combined",
  variable_category = "total",
  variable_detailed = "total_profiles",
  value = combined_total,
  value_type = "count",
  value_source = "calculated"
)

in_clean <- bind_rows(in_clean, combined_row)

cat(paste("Combined total profiles:", format(combined_total, big.mark = ","), "\n"))
cat("✓ Added Combined total profiles\n")
```

#### Calculate Counts from Percentages

Indiana only provides percentages for demographic categories. We calculate the actual counts using the Combined total.

```{r}
#| label: in-calculate-counts
#| echo: false
#| results: hold

# Calculate counts from percentages for Combined offender type
in_clean <- bind_rows(in_clean, calculate_counts_from_percentages(in_clean, "Indiana"))

cat("✓ Calculated demographic counts from percentages\n")

# Verify the calculations
cat("Category totals after calculating counts:\n")
verify_category_totals(in_clean) %>% kable() %>% kable_styling()
```

### Verify Data Consistency

Final checks to ensure all data is now consistent and complete.

```{r}
#| label: in-verify-clean
#| echo: false

cat("Final data consistency checks:\n")
cat(paste("Counts consistent:", counts_consistent(in_clean), "\n"))
cat(paste("Percentages consistent:", percentages_consistent(in_clean), "\n"))

cat("\nFinal data availability:\n")
cat(paste("Race data:", report_status(in_clean, "race"), "\n"))
cat(paste("Gender data:", report_status(in_clean, "gender"), "\n"))
```

### Prepare for Combined Dataset

The cleaned data is formatted to match the master schema and appended to
the `foia_combined` dataframe.

```{r}
#| label: in-prepare-combined
#| echo: false
#| results: hold

# Prepare the cleaned data for the combined dataset
in_prepared <- prepare_state_for_combined(in_clean, "Indiana")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, in_prepared)

cat(paste0("✓ Appended ", nrow(in_prepared), " Indiana rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))
```

### Document Metadata

The metadata is added with details on all processing steps performed.

```{r}
#| label: in-prepare-metadata
#| echo: false
#| results: hold

# Add Indiana to the metadata table using the helper function
add_state_metadata("Indiana", in_raw)

# Update metadata with QC results and processing notes
update_state_metadata("Indiana", 
                      counts_ok = counts_consistent(in_clean),
                      percentages_ok = percentages_consistent(in_clean),
                      notes_text = "Converted string values to numeric; standardized 'Black' to 'African American'; calculated Combined total profiles; derived all demographic counts from reported percentages")
```

### Visualizations

```{r}
#| label: in-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "Indiana DNA Database Demographic Distributions"
#| warning: false
#| message: false

foia_viz_data <- foia_combined %>%
                    filter(offender_type == "Combined")

create_state_visualizations(foia_viz_data, "Indiana")
```

### Summary Statistics

```{r}
#| label: in-summary
#| echo: false
#| results: hold

cat("Indiana DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "Indiana",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value, value_source) %>%
  mutate(value_formatted = format(value, big.mark = ","))

cat("### Total Profiles by Offender Type (Indiana)\n\n")
totals %>%
  select(offender_type, value_formatted, value_source) %>%
  rename(`Offender Type` = offender_type,
         `Total Profiles` = value_formatted,
         `Source` = value_source) %>%
  kable(align = c("l", "r", "l"))

# Data completeness by value source
cat("\n\n### Data Completeness by Source\n\n")
completeness <- foia_combined %>%
  filter(state == "Indiana") %>%
  group_by(value_source) %>%
  summarise(n_values = n(), .groups = "drop")

completeness %>%
  rename(`Value Source` = value_source,
         `Number of Values` = n_values) %>%
  kable(align = c("l", "r"))

# Final verification
cat("\n\n### Data Validation Summary\n\n")
validation_results <- data.frame(
  Check = c("Counts Consistency", "Percentages Consistency"),
  Status = c(
    ifelse(counts_consistent(foia_combined %>% filter(state == "Indiana")), 
           "✓ Pass", "✗ Fail"),
    ifelse(percentages_consistent(foia_combined %>% filter(state == "Indiana")), 
           "✓ Pass", "✗ Fail")
  )
)

kable(validation_results, align = c("l", "c"))
```

### Summary of Indiana Processing

Indiana data processing complete. The unique dataset required:

-   ✅ **Data conversion**: String values converted to numeric, handling
    "\<1" as 0.5

-   ✅ **Terminology standardization**: "Caucasian" converted to "White"

-   ✅ **Calculated additions**:

    -   Combined total profiles across offender types

    -   All demographic counts derived from reported percentages

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation

-   ✅ **Provenance tracking**: Clear distinction between reported and
    calculated values

The Indiana data is now standardized and ready for cross-state analysis.

## Maine (ME)

**Overview**: Maine provides comprehensive reporting with **both counts
and percentages** for all gender and race categories across all offender
types, including pre-calculated Combined totals. The data is complete
and requires no processing.

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: me-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(me_raw)
```

### Verify Data Consistency

Runs quality checks using the `verify_category_totals()`,
`counts_consistent()`, and `percentages_consistent()` functions.

```{r}
#| label: me-verify-raw
#| echo: false

# Check if raw counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
me_category_qc <- verify_category_totals(me_raw)
me_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check on raw data:\n")
cat(paste("All counts consistent:", counts_consistent(me_raw), "\n"))

cat("\nPercentage consistency check on raw data:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(me_raw), "\n"))
```

### Address Data Gaps

#### Solve Percentages Inconsistency

Racial percentages summed to 99.9% instead of 100%

Proportional scaling was applied and `value_source` was updated to "calculated" for all adjusted values.

```{r}
#| label: me-recalculate-percentages
#| echo: false
#| results: hold

# Start with the raw data
me_clean <- me_raw

# Adjust percentages to ensure they sum to 100% and mark as calculated
me_clean <- me_clean %>%
  group_by(value_type, variable_category) %>%
  mutate(
    value = ifelse(
      value_type == "percentage" & variable_category == "gender",
      value * (100 / sum(value, na.rm = TRUE)),
      value
    ),
    value_source = ifelse(
      value_type == "percentage" & variable_category == "gender",
      "calculated",
      value_source
    )
  ) %>%
  ungroup()

# Verify the new sum
percentage_sum <- me_clean %>%
  filter(value_type == "percentage" & variable_category == "gender") %>%
  summarise(total = sum(value, na.rm = TRUE))

cat("✓ Recalculated percentages for Maine - New sum:", round(percentage_sum$total, 2), "%\n")
```

#### Recalculate Counts from Percentages

Maine's reported gender counts sum were inconsistent with the `total_profiles`.

We removed existing gender count data and recalculated counts using percentage values and combined totals.

All recalculated values flagged with `value_source = "calculated"`

```{r}
#| label: me-recalculate-counts
#| echo: false
#| results: hold

# Remove existing gender count rows to avoid duplication
me_clean <- me_clean %>%
  filter(!(variable_category == "gender" & value_type == "count"))

cat("✓ Removed existing gender count data\n")

me_gender <- me_clean %>%
    filter(variable_category == "gender" | variable_category == "total")

# Calculate counts from percentages for Combined offender type
me_gender <- calculate_counts_from_percentages(me_gender, "Maine")

# Append recalculated gender counts to the main dataset
me_clean <- bind_rows(me_clean, me_gender)

cat("✓ Calculated demographic counts from percentages\n")

# Verify the calculations
cat("Category totals after calculating counts:\n")
verify_category_totals(me_clean) %>% kable() %>% kable_styling()
```

### Verify Data Consistency

Final checks to ensure all data is now consistent and complete.

```{r}
#| label: me-verify-clean
#| echo: false

cat("Final data consistency checks:\n")
cat(paste("Counts consistent:", counts_consistent(me_clean), "\n"))
cat(paste("Percentages consistent:", percentages_consistent(me_clean), "\n"))

cat("\nFinal data availability:\n")
cat(paste("Race data:", report_status(me_clean, "race"), "\n"))
cat(paste("Gender data:", report_status(me_clean, "gender"), "\n"))
```

### Prepare for Combined Dataset

The Maine data is already complete and consistent. It is formatted to
match the master schema and appended to the `foia_combined` dataframe.

```{r}
#| label: me-prepare-combined
#| echo: false
#| results: hold

# Prepare the data for the combined dataset
me_prepared <- prepare_state_for_combined(me_clean, "Maine")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, me_prepared)

cat(paste0("✓ Appended ", nrow(me_prepared), " Maine rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))
```

### Document Metadata

The metadata is added with a note that the data was complete and
required no processing.

```{r}
#| label: me-prepare-metadata
#| echo: false
#| results: hold

# Add Maine to the metadata table using the helper function
add_state_metadata("Maine", me_raw)

# Update metadata with QC results
update_state_metadata("Maine", 
                      counts_ok = counts_consistent(me_clean),
                      percentages_ok = percentages_consistent(me_clean),
                      notes_text = "Complete dataset provided with both counts and percentages. No processing or calculations required. All values are reported.")
```

### Visualizations

```{r}
#| label: me-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "Maine DNA Database Demographic Distributions"
#| warning: false
#| message: false

create_state_visualizations(foia_combined, "Maine")
```

### Summary Statistics

```{r}
#| label: me-summary
#| echo: false
#| results: hold

cat("Maine DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "Maine",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value) %>%
  mutate(value_formatted = format(value, big.mark = ","))

cat("### Total Profiles by Offender Type (Maine)\n\n")
totals %>%
  select(offender_type, value_formatted) %>%
  rename(`Offender Type` = offender_type,
         `Total Profiles` = value_formatted) %>%
  kable(align = c("l", "r"))

# Data completeness
cat("\n\n### Data Completeness by Source\n\n")
completeness <- foia_combined %>%
  filter(state == "Maine") %>%
  group_by(offender_type, value_source) %>%
  summarise(n_values = n(), .groups = "drop") %>%
  arrange(offender_type, value_source)

completeness %>%
  rename(`Offender Type` = offender_type,
         `Value Source` = value_source,
         `Number of Values` = n_values) %>%
  kable(align = c("l", "l", "r"))

# Final verification
cat("\n\n### Data Validation Summary\n\n")
validation_results <- data.frame(
  Check = c("Counts Consistency", "Percentages Consistency"),
  Status = c(
    ifelse(counts_consistent(foia_combined %>% filter(state == "Maine")), 
           "✓ Pass", "✗ Fail"),
    ifelse(percentages_consistent(foia_combined %>% filter(state == "Maine")), 
           "✓ Pass", "✗ Fail")
  )
)

kable(validation_results, align = c("l", "c"))
```

### Summary of Maine Processing

Maine data processing complete. The dataset is exemplary and required no
adjustments:

-   ✅ **Reported data**: Both **counts and percentages** for all
    Convicted Offender, Arrestee, and Combined categories

-   ✅ **No calculated additions needed**: All values are sourced
    directly from the state report (**`value_source = "reported"`**)

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation

-   ✅ **Provenance tracking**: All values maintain their original
    **`value_source`** as "reported"

The Maine data is now standardized and ready for cross-state analysis.

## Nevada (NV)

**Overview**: Nevada provides **both counts and percentages** for gender
and race categories but uses non-standard terminology that requires
conversion for consistency with our schema.

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: nv-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(nv_raw)
```

### Verify Data Consistency

Initial check reveals Nevada's non-standard terminology.

```{r}
#| label: nv-verify-raw
#| echo: false

# Check initial data structure
cat("Initial data availability:\n")
cat(paste("Race data:", report_status(nv_raw, "race"), "\n"))
cat(paste("Gender data:", report_status(nv_raw, "gender"), "\n"))

cat("\nNon-standard terminology found:\n")
cat(paste("Offender types:", paste(unique(nv_raw$offender_type), collapse = ", "), "\n"))

```

### Address Data Gaps

#### Standardize Terminology

Nevada uses "All" instead of "Combined", "total_flags" instead of "total_profiles" and "American Indian" instead of
"Native American".

```{r}
#| label: nv-standardize-terminology
#| echo: false
#| results: hold

# Start with raw data
nv_clean <- nv_raw

# Standardize offender types and racial terminology
nv_clean <- nv_clean %>%
  mutate(
    offender_type = case_when(
      offender_type == "All" ~ "Combined",
      TRUE ~ offender_type
    ),
    variable_detailed = case_when(
      variable_detailed == "total_flags" ~ "total_profiles",
      TRUE ~ variable_detailed
    ),
    variable_detailed = case_when(
      variable_detailed == "American Indian" ~ "Native American",
      TRUE ~ variable_detailed
    )
  )

cat("✓ Standardized terminology:\n")
cat("  - 'All' → 'Combined'\n")
cat("  - 'total_flags' → 'total_profiles'\n")
cat("  - 'American Indian' → 'Native American'\n")
```

#### Verify Consistency

Now that the offender types are standardized, we can verify the counts and percentages.

```{r}
#| label: nv-verify-raw-after-standard
#| echo: false

# Check if raw counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
nv_category_qc <- verify_category_totals(nv_clean)
nv_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check on raw data:\n")
cat(paste("All counts consistent:", counts_consistent(nv_clean), "\n"))

nv_gender_race <- nv_clean %>% filter(variable_category != "total")

cat("\nPercentage consistency check on raw data:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(nv_gender_race), "\n\n"))

nv_race <- nv_clean %>%
            filter(variable_category == "race")

nv_gender <- nv_clean %>%
              filter(variable_category == "gender")

# Calculate the sums
race_sum <- sum(nv_race$value[nv_race$value_type == "percentage"], na.rm = TRUE)
gender_sum <- sum(nv_gender$value[nv_gender$value_type == "percentage"], na.rm = TRUE)

# Print the results with cat
cat("Sum of 'race' percentages:", round(race_sum, 1), "%\n")
cat("Sum of 'gender' percentages:", round(gender_sum, 1), "%\n")
```

### Prepare for Combined Dataset

The cleaned data is formatted to match the master schema and appended to
the `foia_combined` dataframe.

```{r}
#| label: nv-prepare-combined
#| echo: false
#| results: hold

# Prepare the cleaned data for the combined dataset
nv_prepared <- prepare_state_for_combined(nv_clean, "Nevada")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, nv_prepared)

cat(paste0("✓ Appended ", nrow(nv_prepared), " Nevada rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))
```

### Document Metadata

The metadata is added with details on the terminology standardization
performed.

```{r}
#| label: nv-prepare-metadata
#| echo: false
#| results: hold

# Add Nevada to the metadata table using the helper function
add_state_metadata("Nevada", nv_raw)

# Update metadata with QC results and processing notes
update_state_metadata("Nevada", 
                      counts_ok = counts_consistent(nv_clean),
                      percentages_ok = percentages_consistent(nv_clean),
                      notes_text = "Standardized terminology: 'All' to 'Combined' and 'American Indian' to 'Native American'. All values remain reported.")
```

### Visualizations

```{r}
#| label: nv-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "Nevada DNA Database Demographic Distributions"
#| warning: false
#| message: false

foia_viz_data <- foia_combined %>%
                    filter(offender_type == "Combined")

create_state_visualizations(foia_viz_data, "Nevada")
```

### Summary Statistics

```{r}
#| label: nv-summary
#| echo: false
#| results: hold

cat("Nevada DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "Nevada",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value) %>%
  mutate(value_formatted = format(value, big.mark = ","))

cat("### Total Profiles by Offender Type (Nevada)\n\n")
totals %>%
  select(offender_type, value_formatted) %>%
  rename(`Offender Type` = offender_type,
         `Total Profiles` = value_formatted) %>%
  kable(align = c("l", "r"))

# Data completeness
cat("\n\n### Data Completeness by Source\n\n")
completeness <- foia_combined %>%
  filter(state == "Nevada") %>%
  group_by(offender_type, value_source) %>%
  summarise(n_values = n(), .groups = "drop") %>%
  arrange(offender_type, value_source)

completeness %>%
  rename(`Offender Type` = offender_type,
         `Value Source` = value_source,
         `Number of Values` = n_values) %>%
  kable(align = c("l", "l", "r"))

# Final verification
cat("\n\n### Data Validation Summary\n\n")
validation_results <- data.frame(
  Check = c("Counts Consistency", "Percentages Consistency"),
  Status = c(
    ifelse(counts_consistent(foia_combined %>% filter(state == "Nevada")), 
           "✓ Pass", "✗ Fail"),
    ifelse(percentages_consistent(foia_combined %>% filter(state == "Nevada")), 
           "✓ Pass", "✗ Fail")
  )
)

kable(validation_results, align = c("l", "c"))
```

### Summary of Nevada Processing

Nevada data processing complete. The dataset required minimal
adjustments:

-   ✅ **Terminology standardization**:

    -   "All" → "Combined" (offender type)

    -   "American Indian" → "Native American" (race category)

-   ✅ **Reported data**: Both counts and percentages for all categories

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation

-   ✅ **Provenance tracking**: All values maintain
    **`value_source = "reported"`** as only terminology changes were
    made

The Nevada data is now standardized and ready for cross-state analysis.

## South Dakota (SD)

**Overview**: South Dakota provides the most comprehensive reporting
with **both counts and percentages** for all standard categories plus
unique intersectional gender×race data. Minor terminology
standardization is required for consistency.

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: sd-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(sd_raw)
```

### Gender-race intersection analysis

Since South Dakota is the only state that reported gender-race intersection data, we can analyze it in detail.

```{r}
#| label: sd-intersectional-visuals
#| echo: false
#| fig-width: 18
#| fig-height: 10
#| fig-fontsize: 16
#| fig-cap: "South Dakota Intersectional Gender × Race Analysis"
#| warning: false
#| message: false
#| layout-ncol: 1

sd_gender_race <- sd_raw %>%
  filter(variable_category == "gender_race")

# Extract intersectional data
sd_intersectional <- sd_gender_race %>%
  separate(variable_detailed, into = c("gender", "race"), sep = "_", remove = FALSE) %>%
  mutate(race = case_when(
    race == "White/Caucasian" ~ "White",
    race == "Other/Unknown" ~ "Unknown",
    TRUE ~ race
  )) %>%
  # Pivot wider to separate count and percentage values
  pivot_wider(
    id_cols = c(gender, race, variable_detailed),
    names_from = value_type,
    values_from = value
  ) %>%
  rename(count_value = count, percentage_value = percentage)

# Heatmap of intersectional percentages
ggplot(sd_intersectional, aes(x = race, y = gender, fill = percentage_value)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = paste0(scales::comma(count_value), "\n(", round(percentage_value, 1), "%)")), 
            color = "white", fontface = "bold", size = 8) +
  scale_fill_gradient(low = "#2166ac", high = "#b2182b", 
                      name = "Percentage of Total") +
  labs(title = "Intersectional Gender × Race Heatmap",
       subtitle = "Count and Percentage of Total Profiles",
       x = "Race Category", 
       y = "Gender") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid = element_blank(),
        text = element_text(size = 28),
        ) 
```

### Verify Data Consistency

Initial check reveals South Dakota's comprehensive data structure with
some non-standard terminology.

```{r}
#| label: sd-verify-raw
#| echo: false

# Remove gender-race intersection

sd_clean <- sd_raw %>%
  filter(variable_category != "gender_race")

# Check initial data availability
cat("Initial data availability:\n")
cat(paste("Race data:", report_status(sd_clean, "race"), "\n"))
cat(paste("Gender data:", report_status(sd_clean, "gender"), "\n"))

cat("\nNon-standard terminology found:\n")
race_terms <- sd_clean %>%
  filter(variable_category == "race") %>%
  distinct(variable_detailed) %>%
  pull()
cat(paste("Race terms:", paste(race_terms, collapse = ", "), "\n"))

# Check if raw counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
sd_category_qc <- verify_category_totals(sd_clean)
sd_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check on raw data:\n")
cat(paste("All counts consistent:", counts_consistent(sd_clean), "\n"))

cat("\nPercentage consistency check on raw data:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(sd_clean), "\n"))

# Categories tables

sd_race <- sd_clean %>%
            filter(variable_category == "race")

sd_gender <- sd_clean %>%
  filter(variable_category == "gender")

# Calculate the sums
race_sum <- sum(sd_race$value[sd_race$value_type == "percentage"], na.rm = TRUE)
gender_sum <- sum(sd_gender$value[sd_gender$value_type == "percentage"], na.rm = TRUE)

# Print the results with cat
cat("Sum of 'race' percentages:", round(race_sum, 1), "%\n")
cat("Sum of 'gender' percentages:", round(gender_sum, 1), "%\n")

```

### Address Data Gaps

#### Standardize Terminology

South Dakota uses "White/Caucasian" and "Other/Unknown" which need
standardization.

```{r}
#| label: sd-standardize-terminology
#| echo: false
#| results: hold

# Standardize racial terminology
sd_clean <- sd_clean %>%
  mutate(
    variable_detailed = case_when(
      variable_detailed == "White/Caucasian" ~ "White",
      variable_detailed == "Other/Unknown" ~ "Unknown",
      TRUE ~ variable_detailed
    )
  )

cat("✓ Standardized terminology:\n")
cat("  - 'White/Caucasian' → 'White'\n")
cat("  - 'Other/Unknown' → 'Unknown'\n")

# Verify the changes
cat("\nRace categories after standardization:\n")
sd_clean %>%
  filter(variable_category == "race") %>%
  distinct(variable_detailed) %>%
  pull() %>%
  paste(collapse = ", ") %>%
  cat()


```

#### Recalculate Counts from Percentages

South Dakota's reported race counts sum were inconsistent with the `total_profiles`.

We removed existing gender count data and recalculated counts using percentage values and combined totals.

All recalculated values flagged with `value_source = "calculated"`

```{r}
#| label: sd-recalculate-counts
#| echo: false
#| results: hold

# Remove existing gender count rows to avoid duplication
sd_clean <- sd_clean %>%
  filter(!(variable_category == "race" & value_type == "count"))

cat("✓ Removed existing race count data\n")

sd_race <- sd_clean %>%
    filter(variable_category == "race" | variable_category == "total")

# Calculate counts from percentages for Combined offender type
sd_race <- calculate_counts_from_percentages(sd_race, "South Dakota")

# Append recalculated race counts to the main dataset
sd_clean <- bind_rows(sd_clean, sd_race)

cat("✓ Calculated demographic counts from percentages\n")

# Verify the calculations
cat("Category totals after calculating counts:\n")
verify_category_totals(sd_clean) %>% kable() %>% kable_styling()


```

We handled this diffence of 1 by adding it to the most representative race (White).

```{r}
#| label: sd-adjust-counts-1
#| echo: false

# Handle the difference of 1 by adding it to the most representative race
sd_clean <- sd_clean %>%
  mutate(value = ifelse(variable_detailed == "White" & value_type == "count", value + 1, value))

```

### Verify Data Consistency

Final checks to ensure standardization didn't affect data integrity.

```{r}
#| label: sd-verify-clean
#| echo: false

cat("Final data consistency checks after standardization:\n")

# Check if standardized counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
sd_category_qc <- verify_category_totals(sd_clean)
sd_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check:\n")
cat(paste("All counts consistent:", counts_consistent(sd_clean), "\n"))

cat("\nPercentage consistency check:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(sd_clean), "\n"))
```

### Prepare for Combined Dataset

The cleaned data is formatted to match the master schema and appended to
the `foia_combined` dataframe.

```{r}
#| label: sd-prepare-combined
#| echo: false
#| results: hold

# Prepare the cleaned data for the combined dataset
sd_prepared <- prepare_state_for_combined(sd_clean, "South Dakota")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, sd_prepared)

cat(paste0("✓ Appended ", nrow(sd_prepared), " South Dakota rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))

# Show the comprehensive nature of South Dakota's data
cat("\nSouth Dakota's comprehensive data structure:\n")
sd_prepared %>%
  group_by(variable_category) %>%
  summarise(n_rows = n(), .groups = "drop") %>%
  kable() %>% kable_styling()
```

### Document Metadata

The metadata is added with details on South Dakota's comprehensive
reporting and the terminology standardization performed.

```{r}
#| label: sd-prepare-metadata
#| echo: false
#| results: hold

# Add South Dakota to the metadata table using the helper function
add_state_metadata("South Dakota", sd_raw)

# Update metadata with QC results and processing notes
update_state_metadata("South Dakota", 
                      counts_ok = counts_consistent(sd_clean),
                      percentages_ok = percentages_consistent(sd_clean),
                      notes_text = "Standardized terminology: 'White/Caucasian' to 'White' and 'Other/Unknown' to 'Unknown'. Includes comprehensive gender_race intersectional data. All values remain reported.")
```

### Visualizations

```{r}
#| label: sd-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "South Dakota DNA Database Demographic Distributions"
#| warning: false
#| message: false

create_state_visualizations(foia_combined, "South Dakota")
```

### Summary Statistics

```{r}
#| label: sd-summary
#| echo: false
#| results: hold

cat("South Dakota DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "South Dakota",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value) %>%
  mutate(value_formatted = format(value, big.mark = ","))

print(totals)

# Data completeness by category
cat("\nData completeness by category:\n")
completeness <- foia_combined %>%
  filter(state == "South Dakota") %>%
  group_by(variable_category) %>%
  summarise(n_values = n(), .groups = "drop")

print(completeness)

# Final verification
cat("\nFinal verification:\n")
cat(paste("Counts consistent:", counts_consistent(foia_combined %>% filter(state == "South Dakota")), "\n"))
cat(paste("Percentages consistent:", percentages_consistent(foia_combined %>% filter(state == "South Dakota")), "\n"))
```

### Summary of South Dakota Processing

South Dakota data processing complete. The state provided exemplary data
with minimal adjustments needed:

-   ✅ **Terminology standardization**:

    -   "White/Caucasian" → "White"

    -   "Other/Unknown" → "Unknown"

-   ✅ **Comprehensive reporting**: Standard demographics plus unique
    gender×race intersectional data

-   ✅ **Reported data**: Both counts and percentages for all categories

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation

-   ✅ **Provenance tracking**: All values maintain
    **`value_source = "reported"`** as only terminology changes were
    made

South Dakota's data is now
standardized and ready for cross-state analysis.

## Texas (TX)

**Overview**: Texas provides **counts only** for gender and race
categories. The Male gender is missing in the dataset. The state uses non-standard terminology that requires
conversion and needs Combined totals and percentages calculated. 

### Examine Raw Data

Establish a baseline understanding of the data exactly as it was
received.

```{r}
#| label: tx-examine
#| echo: false
# Examine the structure of the raw data
enhanced_glimpse(tx_raw)
```

### Verify Data Consistency

Initial checks reveal Texas's reporting structure and terminology
differences.

```{r}
#| label: tx-verify-raw
#| echo: false

# Check initial data availability
cat("Initial data availability:\n")
cat(paste("Race data:", report_status(tx_raw, "race"), "\n"))
cat(paste("Gender data:", report_status(tx_raw, "gender"), "\n"))

cat("\nNon-standard terminology found:\n")
cat(paste("Offender types:", paste(unique(tx_raw$offender_type), collapse = ", "), "\n"))

race_terms <- tx_raw %>%
  filter(variable_category == "race") %>%
  distinct(variable_detailed) %>%
  pull()
cat(paste("Race terms:", paste(race_terms, collapse = ", "), "\n"))
```

### Address Data Gaps

#### Add Missing Male category

Texas data reports only Female counts explicitly. We calculated Male counts
by subtracting Female counts from total profiles, assuming binary gender
classification in the dataset.

```{r}
#| label: tx-male-add
#| echo: false
#| results: hold

# First, let's examine the current structure of gender data
gender_data <- tx_raw %>%
  filter(variable_category == "gender")

cat("Current gender structure:\n")
print(unique(gender_data$variable_detailed))

# Get total profiles for each offender type
total_profiles <- tx_raw %>%
  filter(variable_category == "total" & variable_detailed == "total_profiles") %>%
  select(offender_type, total_value = value)

# Join total profiles with gender data
gender_with_totals <- gender_data %>%
  left_join(total_profiles, by = "offender_type")

# Create Male entries for each offender type
male_entries <- gender_with_totals %>%
  filter(variable_detailed == "Female") %>%
  mutate(
    variable_detailed = "Male",
    value = total_value - value, 
    value_source = "calculated",
    total_value = NULL 
  )

# Add these entries to the original dataset
tx_raw_with_male <- tx_raw %>%
  bind_rows(male_entries)

# Update the tx_raw object
tx_clean <- tx_raw_with_male

# Verify the addition
cat("\nAfter adding Male entries - gender categories:\n")
print(unique(tx_clean %>% 
       filter(variable_category == "gender") %>% 
       pull(variable_detailed)))
```

#### Standardize Terminology

Texas uses "Offenders" instead of "Convicted Offender" and "Caucasian"
instead of "White".

```{r}
#| label: tx-standardize-terminology
#| echo: false
#| results: hold

# Standardize offender types and racial terminology
tx_clean <- tx_clean %>%
  mutate(
    offender_type = case_when(
      offender_type == "Offenders" ~ "Convicted Offender",
      TRUE ~ offender_type
    ),
    variable_detailed = case_when(
      variable_detailed == "Caucasian" ~ "White",
      variable_detailed == "African American" ~ "Black",
      TRUE ~ variable_detailed
    )
  )

cat("✓ Standardized terminology:\n")
cat("  - 'Offenders' → 'Convicted Offender'\n")
cat("  - 'Caucasian' → 'White'\n")
cat("  - 'African American' → 'Black'\n")
cat(paste("Offender types after standardization:", paste(sort(unique(tx_clean$offender_type)), collapse = ", "), "\n"))
```

#### Create Unknown Category

Texas race count is inconsistent, with a significant number of profiles not reported in any racial category.

Unknown category was created to account for these missing profiles.

The calculated values are added with a **`value_source = "calculated"`** tag to maintain transparency about what was provided versus what was derived.

```{r}
#| label: tx-add-unknown
#| echo: false
#| results: hold

# Add Unknown race category to reconcile totals
tx_clean <- fill_demographic_gaps(tx_clean)

# Verify the fix
cat("Category totals after adding Unknown race category:\n")
verify_category_totals(tx_clean) %>% kable() %>% kable_styling()

cat("\nCounts consistency after adding Unknown:\n")
cat(paste("All counts consistent:", counts_consistent(tx_clean), "\n"))
```

#### Create Combined Totals

Texas only reported data for "Convicted Offender" and "Arrestee"
separately. We calculate Combined totals.

```{r}
#| label: tx-create-combined
#| echo: false
#| results: hold

# Calculate Combined totals using helper function
tx_clean <- add_combined(tx_clean)

cat("✓ Created Combined totals for Texas\n")

# Show the Combined total
combined_total <- tx_clean %>%
  filter(offender_type == "Combined",
         variable_category == "total",
         variable_detailed == "total_profiles") %>%
  pull(value)

cat(paste("Combined total profiles:", format(combined_total, big.mark = ","), "\n"))
```

#### Calculate Percentages

Transforms the data from counts into percentages for comparative
analysis.

```{r}
#| label: tx-calculate-percentages
#| echo: false
#| results: hold

# Derive percentages from counts
tx_clean <- add_percentages(tx_clean)

cat("✓ Added percentages for all demographic categories\n")

# Check percentage consistency
cat("Percentage consistency check:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(tx_clean), "\n\n"))

# Show current data availability
cat("Final data availability:\n")
cat(paste("Race data:", report_status(tx_clean, "race"), "\n"))
cat(paste("Gender data:", report_status(tx_clean, "gender"), "\n"))
```

### Verify Data Consistency

Final checks to ensure all processing maintained data integrity.

```{r}
#| label: tx-verify-clean
#| echo: false

cat("Final data consistency checks:\n")

# Check if processed counts sum to reported totals
cat("Verifying that demographic counts match reported totals:\n")
tx_category_qc <- verify_category_totals(tx_clean)
tx_category_qc %>% kable() %>% kable_styling()

cat("\nCounts consistency check:\n")
cat(paste("All counts consistent:", counts_consistent(tx_clean), "\n"))

cat("\nPercentage consistency check:\n")
cat(paste("All percentages sum to ~100%:", percentages_consistent(tx_clean), "\n"))
```

### Prepare for Combined Dataset

The cleaned data is formatted to match the master schema and appended to
the `foia_combined` dataframe.

```{r}
#| label: tx-prepare-combined
#| echo: false
#| results: hold

# Prepare the cleaned data for the combined dataset
tx_prepared <- prepare_state_for_combined(tx_clean, "Texas")

# Append to the master combined dataframe
foia_combined <- bind_rows(foia_combined, tx_prepared)

cat(paste0("✓ Appended ", nrow(tx_prepared), " Texas rows to foia_combined\n"))
cat(paste0("✓ Total rows in foia_combined: ", nrow(foia_combined), "\n"))
```

### Document Metadata

The metadata is added with details on all processing steps performed.

```{r}
#| label: tx-prepare-metadata
#| echo: false
#| results: hold

# Add Texas to the metadata table using the helper function
add_state_metadata("Texas", tx_raw)

# Update metadata with QC results and processing notes
update_state_metadata("Texas", 
                      counts_ok = counts_consistent(tx_clean),
                      percentages_ok = percentages_consistent(tx_clean),
                      notes_text = "Standardized terminology: 'Offenders' to 'Convicted Offender', 'Caucasian' to 'White', 'African American' to 'Black'; calculated Combined totals and all percentages")
```

### Visualizations

```{r}
#| label: tx-visualizations
#| echo: false
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "Texas DNA Database Demographic Distributions"
#| warning: false
#| message: false

create_state_visualizations(foia_combined, "Texas")
```

```{r}
#| label: tx-bar-charts
#| echo: false
#| fig-width: 8
#| fig-height: 12
#| fig-cap: "Texas Demographic Distributions by Offender Type"

create_demographic_bar_charts(foia_combined, "Texas")
```

### Summary Statistics

```{r}
#| label: tx-summary
#| echo: false
#| results: hold

cat("Texas DNA Database Summary:\n")

# Total profiles by offender type
totals <- foia_combined %>%
  filter(state == "Texas",
         variable_category == "total",
         variable_detailed == "total_profiles",
         value_type == "count") %>%
  select(offender_type, value, value_source) %>%
  mutate(value_formatted = format(value, big.mark = ","))

cat("### Total Profiles by Offender Type (Texas)\n\n")
totals %>%
  select(offender_type, value_formatted, value_source) %>%
  rename(`Offender Type` = offender_type,
         `Total Profiles` = value_formatted,
         `Source` = value_source) %>%
  kable(align = c("l", "r", "l"))

# Data completeness by value source
cat("\n\n### Data Completeness by Source\n\n")
completeness <- foia_combined %>%
  filter(state == "Texas") %>%
  group_by(value_source) %>%
  summarise(n_values = n(), .groups = "drop")

completeness %>%
  rename(`Value Source` = value_source,
         `Number of Values` = n_values) %>%
  kable(align = c("l", "r"))

# Final verification
cat("\n\n### Data Validation Summary\n\n")
validation_results <- data.frame(
  Check = c("Counts Consistency", "Percentages Consistency"),
  Status = c(
    ifelse(counts_consistent(foia_combined %>% filter(state == "Texas")), 
           "✓ Pass", "✗ Fail"),
    ifelse(percentages_consistent(foia_combined %>% filter(state == "Texas")), 
           "✓ Pass", "✗ Fail")
  )
)

kable(validation_results, align = c("l", "c"))
```

### Summary of Texas Processing

Texas data processing complete. The dataset required several
adjustments:

-   ✅ **Male Category Addition**:

    -   "Male" added to `variable_detailed`


-   ✅ **Terminology standardization**:

    -   "Offenders" → "Convicted Offender"

    -   "Caucasian" → "White"

    -   "African American" → "Black"

-   ✅ **Calculated additions**:

    -   Combined totals across all offender types

    -   Percentage values for all demographic categories

-   ✅ **Quality checks**: All counts and percentages pass consistency
    validation

-   ✅ **Provenance tracking**: Clear distinction between reported and
    calculated values

The Texas data is now standardized and ready for cross-state analysis.

## Combined Dataset

```{r}
#| label: combine-all-states
#| echo: false

kable(foia_combined, booktabs = TRUE, longtable = TRUE) %>%
  kable_styling(latex_options = c("striped", "scale_down", "repeat_header"),
                font_size = 9)

# Prepare data including Unknown for gender and Unknown/Other for race
combined_data_complete <- foia_combined %>%
  filter(offender_type == "Combined") %>%
  filter(variable_category %in% c("gender", "race")) %>%
  filter(value_type == "count") %>%
  group_by(state, variable_category, variable_detailed) %>%
  summarise(value = sum(value, na.rm = TRUE), .groups = "drop") %>%
  group_by(state, variable_category) %>%
  mutate(percentage = value / sum(value) * 100) %>%
  ungroup()

# GENDER: Stacked bar plot with percentages
gender_stacked <- combined_data_complete %>%
  filter(variable_category == "gender") %>%
  mutate(
    variable_detailed = factor(variable_detailed, levels = c("Male", "Female", "Unknown")),
    label = ifelse(variable_detailed != "Unknown", 
                  paste0(round(percentage, 1), "%"), 
                  "")
  ) %>%
  ggplot(aes(x = reorder(state, percentage), y = percentage, fill = variable_detailed)) +
  geom_col(position = "fill", width = 0.8) +
  geom_text(aes(label = label), 
            position = position_fill(vjust = 0.5), 
            size = 2.5, 
            color = "white",
            fontface = "bold") +
  scale_fill_manual(values = c("Male" = "#4E79A7", "Female" = "#E15759", "Unknown" = "#BAB0AC")) +
  scale_y_continuous(labels = scales::percent_format()) +
  coord_flip() +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  ) +
  labs(x = "State", y = "Percentage", 
       title = "Gender Distribution in State DNA Databases",
       fill = "Gender") +
  guides(fill = guide_legend(reverse = TRUE))

print(gender_stacked)

# RACE: Heatmap with blue gradient and percentages
race_heatmap_blue <- combined_data_complete %>%
  filter(variable_category == "race") %>%
  mutate(
    percentage_label = paste0(round(percentage, 1), "%"),
    # Reorder race categories as specified
    variable_detailed = factor(variable_detailed, 
                              levels = c("White", "Black", "Hispanic", 
                                         "Native American", "Asian", "Other", "Unknown")),
    # Reorder states alphabetically
    state = factor(state, levels = rev(sort(unique(state))))
  ) %>%
  ggplot(aes(x = variable_detailed, y = state, fill = percentage)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = percentage_label), 
            color = "gray30",
            size = 2.5,
            fontface = "bold") +
  scale_fill_gradientn(
    name = "Percentage",
    colors = c("#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"),
    limits = c(0, 100)
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9, color = "gray30"),
    axis.text.y = element_text(size = 8, color = "gray30"),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "right"
  ) +
  labs(x = "Race/Ethnicity", y = "State", 
       title = "Racial Composition in State DNA Databases")

print(race_heatmap_blue)
```

# Conclusions

1. **Data Acquisition and Harmonization**: We ingested seven unique state datasets (`california_foia_data.csv` through `texas_foia_data.csv`), each with distinct reporting formats, terminology, and levels of completeness. Through a systematic processing workflow, we harmonized these into a single, tidy long-format dataset (`foia_combined`), ensuring consistency across all variables.

2. **Standardization of Terminology**: A significant challenge was the non-standard terminology used across states. We implemented a rigorous process to map all state-specific terms to a common data model:

   - **Offender Types**: Standardized to `"Convicted Offender"`, `"Arrestee"`, and `"Combined"`.

   - **Race Categories**: Mapped terms like `"Caucasian"`, `"African American"`, and `"American Indian"` to standardized categories (`"White"`, `"Black"`, `"Native American"`).

   - **Total Profiles**: Consolidated terms like `"total_flags"` to `"total_profiles"`.

3. **Imputation and Calculation of Missing Data**: To ensure comparability, we calculated values that were not directly provided by the states:

   - **Derived Percentages**: For states providing only counts (CA, TX), we calculated percentage compositions.

   - **Derived Counts**: For states providing only percentages (IN), we calculated absolute numbers using reported totals.

   - **Calculated Totals**: We created `"Combined"` offender type totals for states that only reported separate `"Convicted Offender"` and `"Arrestee"` figures.

   - **Inferred Categories**: We added `"Unknown"` race and `"Male"` gender categories where they were logically missing but necessary to reconcile reported totals (CA, TX).

4. **Quality Assurance and Transparency**: A core principle of this project was maintaining transparency and data provenance. This allows future researchers to understand exactly what was provided by the state versus what was derived during processing.

   - **Validation checks**: `counts_consistent()`, `percentages_consistent()`

   - **Value tagging**: `"reported"` or `"calculated"`.

   - **Metadata table**: `foia_state_metadata` provides a clear audit trail of each state's original characteristics and the processing steps applied.